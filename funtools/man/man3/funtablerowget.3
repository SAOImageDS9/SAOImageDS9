.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "funtablerowget 3"
.TH funtablerowget 3 "April 14, 2011" "version 1.4.5" "SAORD Documentation"
.SH "NAME"
FunTableRowGet \- get Funtools rows
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  #include <funtools.h>
.Ve
.PP
.Vb 2
\&  void *FunTableRowGet(Fun fun, void *rows, int maxrow, char *plist,
\&                       int *nrow)
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The \fB\f(BIFunTableRowGet()\fB\fR routine retrieves rows from a Funtools
binary table or raw event file, and places the values of columns
selected by \fIFunColumnSelect()\fR
into an array of user structs.  Selected column values are
automatically converted to the specified user data type (and to native
data format) as necessary.
.PP
The first argument is the Fun handle associated with this row data.
The second \fBrows\fR argument is the array of user structs into
which the selected columns will be stored. If \s-1NULL\s0 is passed, the
routine will automatically allocate space for this array. (This
includes proper allocation of pointers within each struct, if the \*(L"@\*(R"
pointer type is used in the selection of columns.  Note that if you
pass \s-1NULL\s0 in the second argument, you should free this space using the
standard \fIfree()\fR system call when you are finished with the array of
rows.)  The third \fBmaxrow\fR argument specifies the maximum number
of rows to be returned. Thus, if \fBrows\fR is allocated by the
user, it should be at least of size maxrow*sizeof(evstruct).  
.PP
The fourth \fBplist\fR argument is a param list string.  Currently,
the keyword/value pair \*(L"mask=transparent\*(R" is supported in the plist
argument.  If this string is passed in the call's plist argument, then
all rows are passed back to the user (instead of just rows passing
the filter). This is only useful when 
\&\fIFunColumnSelect()\fR also is
used to specify \*(L"$region\*(R" as a column to return for each row.  In
such a case, rows found within a region have a returned region value
greater than 0 (corresponding to the region id of the region in which
they are located), rows passing the filter but not in a region have
region value of \-1, and rows not passing any filter have region
value of 0. Thus, using \*(L"mask=transparent\*(R" and the returned region
value, a program can process all rows and decide on an action based
on whether a given row passed the filter or not.
.PP
The final argument is a pointer to an int variable that will return
the actual number of rows returned.  The routine returns a pointer to
the array of stored rows, or \s-1NULL\s0 if there was an error. (This pointer
will be the same as the second argument, if the latter is non\-NULL).
.PP
.Vb 16
\&  /* get rows -- let routine allocate the row array */
\&  while( (buf = (Ev)FunTableRowGet(fun, NULL, MAXROW, NULL, &got)) ){
\&    /* process all rows */
\&    for(i=0; i<got; i++){
\&      /* point to the i'th row */
\&      ev = buf+i;
\&      /* rearrange some values. etc. */
\&      ev->energy = (ev->pi+ev->pha)/2.0;
\&      ev->pha = \-ev->pha;
\&      ev->pi = \-ev->pi;
\&    }
\&    /* write out this batch of rows */
\&    FunTableRowPut(fun2, buf, got, 0, NULL);
\&    /* free row data */
\&    if( buf ) free(buf);
\&  }
.Ve
.PP
As shown above, successive calls to 
\&\fIFunTableRowGet()\fR will return the
next set of rows from the input file until all rows have been read,
i.e., the routine behaves like sequential Unix I/O calls such as
\&\fIfread()\fR. See evmerge example code for a
more complete example.
.PP
Note that \fIFunTableRowGet()\fR also can be called as \fIFunEventsGet()\fR, for
backward compatibility.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
See funtools(7) for a list of Funtools help pages
