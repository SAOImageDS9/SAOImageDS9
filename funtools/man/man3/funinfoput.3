.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "funinfoput 3"
.TH funinfoput 3 "April 14, 2011" "version 1.4.5" "SAORD Documentation"
.SH "NAME"
FunInfoPut \- put information into a Funtools struct
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  #include <funtools.h>
.Ve
.PP
.Vb 1
\&  int FunInfoPut(Fun fun, int type, char *addr, ...)
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The \fB\f(BIFunInfoPut()\fB\fR routine puts information into a Funtools
structure.  The first argument is the Fun handle from which
information is to be retrieved.  After this first required argument
comes a variable length list of pairs of arguments. Each pair consists
of an integer representing the type of information to store and the
address of the new information to store in the struct. The variable
list is terminated by a 0.  The routine returns the number of put
actions performed.
.PP
The full list of available information is described above with the 
\&\fIFunInfoPut()\fR routine. Although
use of this routine is expected to be uncommon, there is one
important situation in which it plays an essential part: writing
multiple extensions to a single output file.
.PP
For input, multiple extensions are handled by calling 
\&\fIFunOpen()\fR for each extension to be
processed. When opening multiple inputs, it sometimes is the case that
you will want to process them and then write them (including their
header parameters) to a single output file.  To accomplish this, you
open successive input extensions using 
\&\fIFunOpen()\fR and then call
\&\fB\f(BIFunInfoPut()\fB\fR to set the 
Funtools reference handle
of the output file to that of the newly opened input extension:
.PP
.Vb 4
\&  /* open a new input extension */
\&  ifun=FunOpen(tbuf, "r", NULL)) )
\&  /* make the new extension the reference handle for the output file */
\&  FunInfoPut(ofun, FUN_IFUN, &ifun, 0);
.Ve
.PP
Resetting \s-1FUN_IFUN\s0 has same effect as when a funtools handle is passed
as the final argument to 
\&\fIFunOpen()\fR.  The state of the output
file is reset so that a new extension is ready to be written.
Thus, the next I/O call on the output extension will output the
header, as expected.
.PP
For example, in a binary table, after resetting \s-1FUN_IFUN\s0 you can then
call \fIFunColumnSelect()\fR to
select the columns for output. When you then call 
\&\fIFunImagePut()\fR or <A
HREF=\*(L"./library.html#funtablerowput\*(R">\fIFunTableRowPut()\fR, a new
extension will be written that contains the header parameters from the
reference extension. Remember to call 
\&\fIFunFlush()\fR to complete output of a
given extension.
.PP
A complete example of this capability is given
in the evcol example code.
The central algorithm is:
.IP "\(bu" 4
open the output file without a reference handle
.IP "\(bu" 4
loop: open each input extension in turn
.RS 4
.IP "\(bu" 4
set the reference handle for output to the newly opened input extension
.IP "\(bu" 4
read the input rows or image and perform processing
.IP "\(bu" 4
write new rows or image to the output file
.IP "\(bu" 4
flush the output
.IP "\(bu" 4
close input extension
.RE
.RS 4
.RE
.IP "\(bu" 4
close output file
.PP
Note that \fIFunFlush()\fR is called
after processing each input extension in order to ensure that the
proper padding is written to the output file.  A call to 
\&\fIFunFlush()\fR also ensures that the
extension header is written to the output file in the case where there
are no rows to output.
.PP
If you wish to output a new extension without using a 
Funtools reference handle, you can
call \fIFunInfoPut()\fR to reset the \s-1FUN_OPS\s0 value directly.  For a binary
table, you would then call \fIFunColumnSelect()\fR to set up the columns for
this new extension.
.PP
.Vb 6
\&  /* reset the operations performed on this handle */
\&  int ops=0;
\&  FunInfoPut(ofun, FUN_OPS, &ops, 0);
\&  FunColumnSelect(fun, sizeof(EvRec), NULL,
\&                  "MYCOL", "J", "w", FUN_OFFSET(Ev, mycol),
\&                  NULL);
.Ve
.PP
Once the \s-1FUN_OPS\s0 variable has been reset, the next I/O call on the
output extension will output the header, as expected.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
See funtools(7) for a list of Funtools help pages
