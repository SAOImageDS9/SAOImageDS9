.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "funflush 3"
.TH funflush 3 "April 14, 2011" "version 1.4.5" "SAORD Documentation"
.SH "NAME"
FunFlush \- flush data to output file
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  #include <funtools.h>
.Ve
.PP
.Vb 1
\&  void FunFlush(Fun fun, char *plist)
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The \fBFunFlush\fR routine will flush data to a \s-1FITS\s0 output file.  In
particular, it can be called after all rows have been written (using
the \fIFunTableRowPut()\fR routine)
in order to add the null padding that is required to complete a \s-1FITS\s0
block. It also should be called after completely writing an image using
\&\fIFunImagePut()\fR or after writing
the final row of an image using
\&\fIFunTableRowPut()\fR.
.PP
The \fBplist\fR (i.e., parameter list) argument is a string
containing one or more comma-delimited \fBkeyword=value\fR
parameters.  If the plist string contains the parameter
\&\*(L"copy=remainder\*(R" and the file was opened with a reference file, which,
in turn, was opened for extension copying (i.e. the input 
\&\fIFunOpen()\fR mode also was \*(L"c\*(R" or \*(L"C\*(R"),
then FunFlush also will copy the remainder of the \s-1FITS\s0 extensions from
the input reference file to the output file.  This normally would be
done only at the end of processing.
.PP
Note that \fIFunFlush()\fR is called
with \*(L"copy=remainder\*(R" in the mode string by \fIFunClose()\fR.  This means
that if you close the output file before the reference input file, it
is not necessary to call 
\&\fIFunFlush()\fR explicitly, unless you
are writing more than one extension.  See the 
evmerge example code. However, it is safe to
call \fIFunFlush()\fR more than once
without fear of re-writing either the padding or the copied
extensions.
.PP
In addition, if \fIFunFlush()\fR is
called on an output file with the plist set to \*(L"copy=reference\*(R" and if
the file was opened with a reference file, the reference extension is
written to the output file.  This mechanism provides a simple way to
copy input extensions to an output file without processing the former.
For example, in the code fragment below, an input extension is set to
be the reference file for a newly opened output extension. If that
reference extension is not a binary table, it is written to the output
file:
.PP
.Vb 22
\&  /* process each input extension in turn */
\&  for(ext=0; ;ext++){
\&    /* get new extension name */
\&    sprintf(tbuf, "%s[%d]", argv[1], ext);
\&    /* open input extension -- if we cannot open it, we are done */
\&    if( !(ifun=FunOpen(tbuf, "r", NULL)) )
\&      break;
\&    /* make the new extension the reference handle for the output file */
\&    FunInfoPut(ofun, FUN_IFUN, &ifun, 0);
\&    /* if its not a binary table, just write it out */
\&    if( !(s=FunParamGets(ifun, "XTENSION", 0, NULL, &got)) || 
\&      strcmp(s, "BINTABLE")){
\&      if( s ) free(s);
\&      FunFlush(ofun, "copy=reference");
\&      FunClose(ifun);
\&      continue;
\&    }
\&    else{
\&      /* process binary table */
\&      ....
\&    }
\&  }
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
See funtools(7) for a list of Funtools help pages
