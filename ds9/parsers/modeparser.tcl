package provide DS9 1.0

######
# Begin autogenerated taccle (version 1.3) routines.
# Although taccle itself is protected by the GNU Public License (GPL)
# all user-supplied functions are protected by their respective
# author's license.  See http://mini.net/tcl/taccle for other details.
######

namespace eval mode {
    variable yylval {}
    variable table
    variable rules
    variable token {}
    variable yycnt 0
    variable yyerr 0
    variable save_state 0

    namespace export yylex
}

proc mode::YYABORT {} {
    return -code return 1
}

proc mode::YYACCEPT {} {
    return -code return 0
}

proc mode::YYERROR {} {
    variable yyerr
    set yyerr 1
}

proc mode::yyclearin {} {
    variable token
    variable yycnt
    set token {}
    incr yycnt -1
}

proc mode::yyerror {s} {
    puts stderr $s
}

proc mode::setupvalues {stack pointer numsyms} {
    upvar 1 1 y
    set y {}
    for {set i 1} {$i <= $numsyms} {incr i} {
        upvar 1 $i y
        set y [lindex $stack $pointer]
        incr pointer
    }
}

proc mode::unsetupvalues {numsyms} {
    for {set i 1} {$i <= $numsyms} {incr i} {
        upvar 1 $i y
        unset y
    }
}

array set mode::table {
  17:257 shift
  0:258 shift
  5:0,target 8
  0:260 shift
  0:259 shift
  2:257 reduce
  15:0,target 1
  9:0 reduce
  8:257,target 11
  0:261 shift
  0:266,target 9
  11:0 reduce
  0:262 shift
  4:257 reduce
  0:263 shift
  6:257 reduce
  0:264 shift
  3:257,target 6
  0:265 shift
  15:0 reduce
  8:257 reduce
  0:266 shift
  15:257,target 2
  0:267 shift
  0:265,target 8
  0:268 shift
  15:272 goto
  6:0,target 9
  0:269 shift
  0:270 shift
  16:0,target 4
  10:257,target 13
  0:271 goto
  2:0 reduce
  0:273 goto
  0:274 goto
  6:0 reduce
  6:257,target 9
  0:264,target 7
  0:274,target 16
  7:0,target 10
  1:257,target 5
  12:0 reduce
  10:0,target 13
  13:257,target 16
  0:263,target 6
  16:0 reduce
  10:257 reduce
  0:273,target 15
  12:257 reduce
  9:257,target 12
  8:0,target 11
  3:0 reduce
  18:0,target 3
  1:0,target 5
  16:257 reduce
  11:0,target 14
  4:257,target 7
  0:262,target 5
  7:0 reduce
  1:257 reduce
  16:257,target 4
  3:257 reduce
  11:257,target 14
  5:257 reduce
  13:0 reduce
  9:0,target 12
  0:261,target 4
  7:257 reduce
  0:271,target 14
  2:0,target 17
  12:0,target 15
  9:257 reduce
  7:257,target 10
  0:260,target 3
  0:259,target 2
  2:257,target 17
  15:272,target 17
  0:269,target 12
  0:270,target 13
  4:0 reduce
  3:0,target 6
  13:0,target 16
  8:0 reduce
  10:0 reduce
  0:258,target 1
  0:268,target 11
  14:0 accept
  5:257,target 8
  4:0,target 7
  14:0,target 0
  11:257 reduce
  18:0 reduce
  17:257,target 18
  1:0 reduce
  13:257 reduce
  0:267,target 10
  15:257 reduce
  12:257,target 15
  5:0 reduce
}

array set mode::rules {
  9,l 274
  11,l 274
  15,l 274
  2,l 272
  6,l 274
  12,l 274
  16,l 274
  3,l 271
  7,l 274
  13,l 274
  0,l 275
  17,l 274
  4,l 273
  8,l 274
  10,l 274
  14,l 274
  1,l 271
  5,l 274
}

array set mode::rules {
  5,dc 1
  0,dc 1
  17,dc 1
  12,dc 1
  8,dc 1
  3,dc 3
  15,dc 1
  10,dc 1
  6,dc 1
  1,dc 1
  13,dc 1
  9,dc 1
  4,dc 1
  16,dc 1
  11,dc 1
  7,dc 1
  2,dc 0
  14,dc 1
}

array set mode::rules {
  13,line 43
  2,e 1
  7,line 37
  10,line 40
  4,line 32
  1,line 28
  15,line 45
  9,line 39
  12,line 42
  6,line 36
  3,line 29
  17,line 48
  14,line 44
  8,line 38
  11,line 41
  5,line 35
  2,line 28
  16,line 47
}

array set mode::lr1_table {
  17 {{3 0 2}}
  13,trans {}
  0 {{0 0 0} {1 0 0} {3 0 0} {4 {0 257} 0} {5 {0 257} 0} {6 {0 257} 0} {7 {0 257} 0} {8 {0 257} 0} {9 {0 257} 0} {10 {0 257} 0} {11 {0 257} 0} {12 {0 257} 0} {13 {0 257} 0} {14 {0 257} 0} {15 {0 257} 0} {16 {0 257} 0} {17 {0 257} 0}}
  18 {{3 0 3}}
  14,trans {}
  1 {{5 {0 257} 1}}
  15,trans {{272 17}}
  2 {{17 {0 257} 1}}
  16,trans {}
  3 {{6 {0 257} 1}}
  17,trans {{257 18}}
  0,trans {{258 1} {259 2} {260 3} {261 4} {262 5} {263 6} {264 7} {265 8} {266 9} {267 10} {268 11} {269 12} {270 13} {271 14} {273 15} {274 16}}
  4 {{7 {0 257} 1}}
  18,trans {}
  1,trans {}
  5 {{8 {0 257} 1}}
  2,trans {}
  6 {{9 {0 257} 1}}
  3,trans {}
  7 {{10 {0 257} 1}}
  4,trans {}
  8 {{11 {0 257} 1}}
  5,trans {}
  9 {{12 {0 257} 1}}
  10 {{13 {0 257} 1}}
  6,trans {}
  11 {{14 {0 257} 1}}
  7,trans {}
  12 {{15 {0 257} 1}}
  8,trans {}
  13 {{16 {0 257} 1}}
  10,trans {}
  9,trans {}
  14 {{0 0 1}}
  11,trans {}
  15 {{1 0 1} {3 0 1} {2 257 0}}
  12,trans {}
  16 {{4 {0 257} 1}}
}

array set mode::token_id_table {
  264,line 17
  270,t 0
  269,t 0
  265,title ROTATE
  274,t 1
  261,line 14
  257,t 0
  270,title 3D
  269,title EXAMINE
  273,line 31
  257,line 7
  262,t 0
  274,title {}
  270,line 23
  269,line 22
  259,title POINTER
  260,title REGION
  266,t 0
  271,t 1
  error error
  264,title ZOOM
  266,line 19
  275,t 1
  error,line 26
  268,title FOOTPRINT
  258,t 0
  263,line 16
  error,title {}
  275,line 49
  273,title {}
  263,t 0
  259,line 12
  260,line 13
  258,title NONE
  272,line 28
  267,t 0
  263,title PAN
  272,t 1
  268,line 21
  267,title CATALOG
  257 STRING_
  258 NONE_
  259,t 0
  259 POINTER_
  260 REGION_
  260,t 0
  272,title {}
  261 CROSSHAIR_
  265,line 18
  262 COLORBAR_
  263 PAN_
  257,title string
  264 ZOOM_
  264,t 0
  265 ROTATE_
  262,line 15
  266 CROP_
  267 CATALOG_
  0,t 0
  0 {$}
  262,title COLORBAR
  268 FOOTPRINT_
  268,t 0
  274,line 34
  270 3D_
  269 EXAMINE_
  271 command
  error,t 0
  272 @PSEUDO1
  258,line 11
  273,t 1
  273 mode
  266,title CROP
  274 item
  275 start'
  271,line 27
  271,title {}
  261,t 0
  267,line 20
  275,title {}
  265,t 0
  261,title CROSSHAIR
}

proc mode::yyparse {} {
    variable yylval
    variable table
    variable rules
    variable token
    variable yycnt
    variable lr1_table
    variable token_id_table
    variable yyerr
    variable save_state

    set yycnt 0
    set state_stack {0}
    set value_stack {{}}
    set token ""
    set accepted 0
    set yyerr 0
    set save_state 0

    while {$accepted == 0} {
        set state [lindex $state_stack end]
        if {$token == ""} {
            set yylval ""
            set token [yylex]
            set buflval $yylval
	    if {$token>0} {
	        incr yycnt
            }
        }
        if {![info exists table($state:$token)] || $yyerr} {
	    if {!$yyerr} {
	        set save_state $state
	    }
            # pop off states until error token accepted
            while {[llength $state_stack] > 0 && \
                       ![info exists table($state:error)]} {
                set state_stack [lrange $state_stack 0 end-1]
                set value_stack [lrange $value_stack 0 \
                                       [expr {[llength $state_stack] - 1}]]
                set state [lindex $state_stack end]
            }
            if {[llength $state_stack] == 0} {
 
	        set rr { }
                if {[info exists lr1_table($save_state,trans)] && [llength $lr1_table($save_state,trans)] >= 1} {
                    foreach trans $lr1_table($save_state,trans) {
                        foreach {tok_id nextstate} $trans {
			    set ss $token_id_table($tok_id,title)
			    if {$ss != {}} {
			        append rr "$ss, "
                            }
                        }
                    }
                }
		set rr [string trimleft $rr { }]
		set rr [string trimright $rr {, }]
                yyerror "parse error, expecting: $rr"


                return 1
            }
            lappend state_stack [set state $table($state:error,target)]
            lappend value_stack {}
            # consume tokens until it finds an acceptable one
            while {![info exists table($state:$token)]} {
                if {$token == 0} {
                    yyerror "end of file while recovering from error"
                    return 1
                }
                set yylval {}
                set token [yylex]
                set buflval $yylval
            }
            continue
        }
        switch -- $table($state:$token) {
            shift {
                lappend state_stack $table($state:$token,target)
                lappend value_stack $buflval
                set token ""
            }
            reduce {
                set rule $table($state:$token,target)
                set ll $rules($rule,l)
                if {[info exists rules($rule,e)]} {
                    set dc $rules($rule,e)
                } else {
                    set dc $rules($rule,dc)
                }
                set stackpointer [expr {[llength $state_stack]-$dc}]
                setupvalues $value_stack $stackpointer $dc
                set _ $1
                set yylval [lindex $value_stack end]
                switch -- $rule {
                    2 { global ds9; if {!$ds9(init)} {YYERROR} else {yyclearin; YYACCEPT} }
                    4 { ProcessCmdSet current mode $1 ChangeMode }
                    5 { set _ none }
                    6 { set _ region }
                    7 { set _ crosshair }
                    8 { set _ colorbar }
                    9 { set _ pan }
                    10 { set _ zoom }
                    11 { set _ rotate }
                    12 { set _ crop }
                    13 { set _ catalog }
                    14 { set _ footprint }
                    15 { set _ examine }
                    16 { set _ 3d }
                    17 { set _ region }
                }
                unsetupvalues $dc
                # pop off tokens from the stack if normal rule
                if {![info exists rules($rule,e)]} {
                    incr stackpointer -1
                    set state_stack [lrange $state_stack 0 $stackpointer]
                    set value_stack [lrange $value_stack 0 $stackpointer]
                }
                # now do the goto transition
                lappend state_stack $table([lindex $state_stack end]:$ll,target)
                lappend value_stack $_
            }
            accept {
                set accepted 1
            }
            goto -
            default {
                puts stderr "Internal parser error: illegal command $table($state:$token)"
                return 2
            }
        }
    }
    return 0
}

######
# end autogenerated taccle functions
######

proc mode::yyerror {msg} {
     variable yycnt
     variable yy_current_buffer
     variable index_

     ParserError $msg $yycnt $yy_current_buffer $index_
}
