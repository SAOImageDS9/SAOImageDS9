.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "funimageget 3"
.TH funimageget 3 "April 14, 2011" "version 1.4.5" "SAORD Documentation"
.SH "NAME"
FunImageGet \- get an image or image section
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  #include <funtools.h>
.Ve
.PP
.Vb 1
\&  void *FunImageGet(Fun fun, void *buf, char *plist)
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The \fB\f(BIFunImageGet()\fB\fR routine returns an binned image array of the
specified section of a Funtools data file.  If the input data are
already of type image, the array is generated by extracting the
specified image section and then binning it according to the specified
bin factor.  If the input data are contained in a binary table or raw
event file, the rows are binned on the columns specified by the
\&\fBbincols=\fR keyword (using appropriate default columns as
necessary), after which the image section and bin factors are
applied. In both cases, the data is automatically converted from \s-1FITS\s0
to native format, if necessary.
.PP
The first argument is the Funtools handle returned by 
\&\fIFunOpen()\fR.  The second \fBbuf\fR
argument is a pointer to a data buffer to fill. If \s-1NULL\s0 is specified,
FunImageGet will allocate a buffer of the appropriate size. Generally
speaking, you always want Funtools to allocate the buffer because
the image dimensions will be determined by
Funtools image sectioning
on the command line.
.PP
The third \fBplist\fR (i.e., parameter list) argument is a string
containing one or more comma-delimited \fBkeyword=value\fR
parameters.  It can be used to specify the return data type using the
\&\fBbitpix=\fR keyword.  If no such keyword is specified in the plist
string, the data type of the returned image is the same as the data type
of the original input file, or is of type int for \s-1FITS\s0 binary tables.
.PP
If the \fBbitpix=\fR keyword is supplied in the plist string, the data
type of the returned image will be one of the supported \s-1FITS\s0 image
data types:
.IP "\(bu" 4
8 unsigned char
.IP "\(bu" 4
16 short
.IP "\(bu" 4
32 int
.IP "\(bu" 4
\&\-32 float
.IP "\(bu" 4
\&\-64 double
.PP
For example:
.PP
.Vb 4
\&  void *buf;
\&  /* extract data section into an image buffer */
\&  if( !(buf = FunImageGet(fun, NULL, NULL)) )
\&    gerror(stderr, "could not FunImageGet: %s\en", iname);
.Ve
.PP
will allocate buf and retrieve the image in the file data format. In
this case, you will have to determine the data type (using the
\&\s-1FUN_SECT_BITPIX\s0 value in the 
\&\fIFunInfoGet()\fR
routine)
and then use a switch statement to process each data type:
.PP
.Vb 17
\&  int bitpix;
\&  void *buf;
\&  unsigned char *cbuf;
\&  short *sbuf;
\&  int *ibuf;
\&  ...
\&  buf = FunImageGet(fun, NULL, NULL);
\&  FunInfoGet(fun, FUN_SECT_BITPIX,  &bitpix, 0);
\&  /* set appropriate data type buffer to point to image buffer */
\&  switch(bitpix){
\&  case 8:
\&    cbuf = (unsigned char *)buf; break;
\&  case 16:
\&    sbuf = (short *)buf; break;
\&  case 32:
\&    ibuf = (int *)buf; break;
\& ...
.Ve
.PP
See the 
imblank example code
for more details on how to process an image when the data type is not
specified beforehand.
.PP
It often is easier to specify the data type directly:
.PP
.Vb 4
\&  double *buf;
\&  /* extract data section into a double image buffer */
\&  if( !(buf = FunImageGet(fun, NULL, "bitpix=-64")) )
\&    gerror(stderr, "could not FunImageGet: %s\en", iname);
.Ve
.PP
will extract the image while converting to type double.
.PP
On success, a pointer to the image buffer is returned. (This will be
the same as the second argument, if \s-1NULL\s0 is not passed to the latter.)
On error, \s-1NULL\s0 is returned.
.PP
In summary, to retrieve image or row data into a binned image, you simply
call \fIFunOpen()\fR followed by 
\&\fIFunImageGet()\fR.  Generally, you
then will want to call
\&\fIFunInfoGet()\fR
to retrieve the
axis dimensions (and data type) of the section you are processing
(so as to take account of sectioning and blocking of the original data):
.PP
.Vb 4
\&  double *buf;
\&  int i, j;
\&  int dim1, dim2;
\&  ... other declarations, etc.
.Ve
.PP
.Vb 3
\&  /* open the input FITS file */
\&  if( !(fun = FunOpen(argv[1], "rc", NULL)) )
\&    gerror(stderr, "could not FunOpen input file: %s\en", argv[1]);
.Ve
.PP
.Vb 3
\&  /* extract and bin the data section into a double float image buffer */
\&  if( !(buf = FunImageGet(fun, NULL, "bitpix=-64")) )
\&    gerror(stderr, "could not FunImageGet: %s\en", argv[1]);
.Ve
.PP
.Vb 2
\&  /* get dimension information from funtools structure */
\&  FunInfoGet(fun, FUN_SECT_DIM1, &dim1, FUN_SECT_DIM2, &dim2, 0);
.Ve
.PP
.Vb 4
\&  /* loop through pixels and reset values below limit to value */
\&  for(i=0; i<dim1*dim2; i++){
\&    if( buf[i] <= blimit ) buf[i] = bvalue;
\&  }
.Ve
.PP
Another useful plist string value is \*(L"mask=all\*(R", which returns an
image populated with regions id values. Image pixels within a region
will contain the associated region id (region values start at 1), and
otherwise will contain a 0 value. Thus, the returned image is a
region mask which can be used to process the image data (which
presumably is retrieved by a separate call to FunImageGet) pixel by
pixel.
.PP
If a \s-1FITS\s0 binary table or a non-FITS raw event file is being binned
into an image, it is necessary to specify the two columns that will be
used in the 2D binning.  This usually is done on the command line
using the \fBbincols=(x,y)\fR keyword:
.PP
.Vb 1
\&  funcnts "foo.ev[EVENTS,bincols=(detx,dety)]"
.Ve
.PP
The full form of the \fBbincols=\fR specifier is:
.PP
.Vb 1
\&  bincols=([xname[:tlmin[:tlmax:[binsiz]]]],[yname[:tlmin[:tlmax[:binsiz]]]])
.Ve
.PP
where the tlmin, tlmax, and binsiz specifiers determine the image binning
dimensions:
.PP
.Vb 2
\&  dim = (tlmax - tlmin)/binsiz     (floating point data)
\&  dim = (tlmax - tlmin)/binsiz + 1 (integer data)
.Ve
.PP
These tlmin, tlmax, and binsiz specifiers can be omitted if \s-1TLMIN\s0,
\&\s-1TLMAX\s0, and \s-1TDBIN\s0 header parameters (respectively) are present in the
\&\s-1FITS\s0 binary table header for the column in question.  Note that if
only one parameter is specified, it is assumed to be tlmax, and tlmin
defaults to 1. If two parameters are specified, they are assumed to be
tlmin and tlmax.
.PP
If \fBbincols\fR is not specified on the command line, Funtools tries
to use appropriate defaults: it looks for the environment variable
\&\s-1FITS_BINCOLS\s0 (or \s-1FITS_BINKEY\s0). Then it looks for the Chandra
parameters \s-1CPREF\s0 (or \s-1PREFX\s0) in the \s-1FITS\s0 binary table header. Failing
this, it looks for columns named \*(L"X\*(R" and \*(L"Y\*(R" and if these are not
found, it looks for columns containing the characters \*(L"X\*(R" and \*(L"Y\*(R".
.PP
See Binning \s-1FITS\s0 Binary Tables and
Non-FITS Event Files for more information.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
See funtools(7) for a list of Funtools help pages
