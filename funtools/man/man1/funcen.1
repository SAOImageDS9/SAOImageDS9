.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "funcen 1"
.TH funcen 1 "April 14, 2011" "version 1.4.5" "SAORD Documentation"
.SH "NAME"
funcen \- find centroid (for binary tables)
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
\&\fBfuncen\fR [\-i] [\-n iter] [\-t tol] [\-v lev] <iname> <region>
.SH "OPTIONS"
.IX Header "OPTIONS"
.Vb 4
\&  \-i            # use image filtering (default: event filtering)
\&  \-n iter       # max number of iterations (default: 0)
\&  \-t tol        # pixel tolerance distance (default: 1.0)
\&  \-v [0,1,2,3]  # output verbosity level (default: 0)
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\fBfuncen\fR iteratively calculates the centroid position within one
or more regions of a Funtools table (\s-1FITS\s0 binary table or raw event
file).  Starting with an input table, an initial region specification,
and an iteration count, the program calculates the average x and y
position within the region and then uses this new position as the
region center for the next iteration. Iteration terminates when the
maximum number of iterations is reached or when the input tolerance
distance is met for that region. A count of events in the final region
is then output, along with the pixel position value (and, where
available, \s-1WCS\s0 position).
.PP
The first argument to the program specifies the Funtools table file to
process.  Since the file must be read repeatedly, a value of \*(L"stdin\*(R"
is not permitted when the number of iterations is non\-zero.  Use 
Funtools Bracket Notation to specify \s-1FITS\s0
extensions and filters.
.PP
The second required argument is the initial region descriptor. Multiple
regions are permitted. However, compound regions (accelerators,
variable argument regions and regions connected via boolean algebra)
are not permitted. Points and polygons also are illegal. These
restrictions might be lifted in a future version, if warranted.
.PP
The \fB\-n\fR (iteration number) switch specifies the maximum number of
iterations to perform. The default is 0, which means that the program will
simply count and display the number of events in the initial region(s).
Note that when iterations is 0, the data can be input via stdin.
.PP
The \fB\-t\fR (tolerance) switch specifies a floating point tolerance
value. If the distance between the current centroid position value and
the last position values is less than this value, iteration terminates.
The default value is 1 pixel.
.PP
The \fB\-v\fR (verbosity) switch specifies the verbosity level of the
output. The default is 0, which results in a single line of output for
each input region consisting of the following values:
.PP
.Vb 1
\&  counts x y [ra dec coordsys]
.Ve
.PP
The last 3 \s-1WCS\s0 values are output if \s-1WCS\s0 information is available in the
data file header. Thus, for example:
.PP
.Vb 2
\&  [sh] funcen \-n 0 snr.ev "cir 505 508 5"
\&  915 505.00 508.00 345.284038 58.870920 j2000
.Ve
.PP
.Vb 2
\&  [sh] funcen \-n 3 snr.ev "cir 505 508 5"
\&  1120 504.43 509.65 345.286480 58.874587 j2000
.Ve
.PP
The first example simply counts the number of events in the initial region.
The second example iterates the centroid calculation three times to determine
a final \*(L"best\*(R" position.
.PP
Higher levels of verbosity obviously imply more verbose output. At
level 1, the output essentially contains the same information as level
0, but with keyword formatting:
.PP
.Vb 5
\&  [sh] funcen \-v 1 \-n 3 snr.ev "cir 505 508 5"
\&  event_file:     snr.ev
\&  initial_region: cir 505 508 5
\&  tolerance:      1.0000
\&  iterations:     1
.Ve
.PP
.Vb 4
\&  events:         1120
\&  x,y(physical):  504.43 509.65
\&  ra,dec(j2000):  345.286480 58.874587
\&  final_region1:  cir 504.43 509.65 5
.Ve
.PP
Level 2 outputs results from intermediate calculations as well.
.PP
Ordinarily, region filtering is performed using analytic (event)
filtering, i.e. that same style of filtering as is performed by
\&\fBfundisp\fR and \fBfuntable\fR. Use the \fB\-i\fR switch to specify image
filtering, i.e. the same style filtering as is performed by \fBfuncnts\fR.
Thus, you can perform a quick calculation of counts in regions, using
either the analytic or image filtering method, by specifying the
 \fB\-n 0\fR and optional \fB\-i\fR switches. These two method often
give different results because of how boundary events are processed:
.PP
.Vb 2
\&  [sh] funcen  snr.ev "cir 505 508 5"
\&  915 505.00 508.00 345.284038 58.870920 j2000
.Ve
.PP
.Vb 2
\&  [sh] funcen \-i snr.ev "cir 505 508 5"
\&  798 505.00 508.00 345.284038 58.870920 j2000
.Ve
.PP
See Region Boundaries for more information
about how boundaries are calculated using these two methods.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
See funtools(7) for a list of Funtools help pages
