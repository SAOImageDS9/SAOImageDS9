.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "funimagerowget 3"
.TH funimagerowget 3 "April 14, 2011" "version 1.4.5" "SAORD Documentation"
.SH "NAME"
FunImageRowGet \- get row(s) of an image
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  #include <funtools.h>
.Ve
.PP
.Vb 2
\&  void *FunImageRowGet(Fun fun, void *buf, int rstart, int rstop,
\&                       char *plist)
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The \fB\f(BIFunImageRowGet()\fB\fR routine returns one or more image rows
from the specified section of a Funtools data file.  If the input data
are of type image, the array is generated by extracting the specified
image rows and then binning them according to the specified bin
factor.  If the input data are contained in a binary table or raw
event file, the rows are binned on the columns specified by the
\&\fBbincols=\fR keyword (using appropriate default columns as needed),
after which the image section and bin factors are applied.
.PP
The first argument is the Funtools handle returned by 
\&\fIFunOpen()\fR.  The second \fBbuf\fR
argument is a pointer to a data buffer to fill. If \s-1NULL\s0 is specified,
\&\fIFunImageGet()\fR will allocate a buffer of the appropriate size.
.PP
The third and fourth arguments specify the first and last row to
retrieve.  Rows are counted starting from 1, up to the value of
\&\s-1FUN_YMAX\s0(fun).  The final \fBplist\fR (i.e., parameter list) argument
is a string containing one or more comma-delimited
\&\fBkeyword=value\fR parameters.  It can be used to specify the return
data type using the \fBbitpix=\fR keyword.  If no such keyword is
specified in the plist string, the data type of the image is the same
as the data type of the original input file, or is of type int for
\&\s-1FITS\s0 binary tables.
.PP
If the \fBbitpix=\fRvalue is supplied in the plist string, the data
type of the returned image will be one of the supported \s-1FITS\s0 image
data types:
.IP "\(bu" 4
8 unsigned char
.IP "\(bu" 4
16 short
.IP "\(bu" 4
32 int
.IP "\(bu" 4
\&\-32 float
.IP "\(bu" 4
\&\-64 double
.PP
For example:
.PP
.Vb 17
\&  double *drow;
\&  Fun fun;
\&  ... open files ...
\&  /* get section dimensions */
\&  FunInfoGet(fun, FUN_SECT_DIM1, &dim1, FUN_SECT_DIM2, &dim2, 0);
\&  /* allocate one line's worth */
\&  drow = malloc(dim1*sizeof(double));
\&  /* retrieve and process each input row (starting at 1) */
\&  for(i=1; i <= dim2; i++){
\&    if( !FunImageRowGet(fun, drow, i, i, "bitpix=-64") )
\&      gerror(stderr, "can't FunImageRowGet: %d %s\en", i, iname);
\&      /* reverse the line */
\&      for(j=1; j<=dim1; j++){
\&        ... process drow[j-1] ...
\&      }
\&  }
\&  ...
.Ve
.PP
On success, a pointer to the image buffer is returned. (This will be
the same as the second argument, if \s-1NULL\s0 is not passed to the latter.)
On error, \s-1NULL\s0 is returned.  Note that the considerations described
above for specifying binning columns in 
\&\fIFunImageGet()\fR also apply to
\&\fB\f(BIFunImageRowGet()\fB\fR.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
See funtools(7) for a list of Funtools help pages
