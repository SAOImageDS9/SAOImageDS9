.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "funopen 3"
.TH funopen 3 "April 14, 2011" "version 1.4.5" "SAORD Documentation"
.SH "NAME"
FunOpen \- open a Funtools data file
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  #include <funtools.h>
.Ve
.PP
.Vb 1
\&  Fun FunOpen(char *name, char *mode, Fun ref);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The \fB\f(BIFunOpen()\fB\fR routine opens a Funtools data file for reading or
appending, or creates a new \s-1FITS\s0 file for writing. The \fBname\fR
argument specifies the name of the Funtools data file to open. You can
use IRAF-style bracket notation to specify
Funtools Files, Extensions, and Filters.
A separate call should be made each time a different \s-1FITS\s0 extension is
accessed:
.PP
.Vb 7
\&  Fun fun;
\&  char *iname;
\&  ...
\&  if( !(fun = FunOpen(iname, "r", NULL)) ){
\&    fprintf(stderr, "could not FunOpen input file: %s\en", iname);
\&    exit(1);
\&  }
.Ve
.PP
If \fBmode\fR is \*(L"r\*(R", the file is opened for reading, and processing
is set up to begin at the specified extension. For reading,
\&\fBname\fR can be \fBstdin\fR, in which case the standard input is read.
.PP
If \fBmode\fR is \*(L"w\*(R", the file is created if it does not exist, or
opened and truncated for writing if it does exist. Processing starts
at the beginning of the file.  The \fBname\fR can be \fBstdout\fR,
in which case the standard output is readied for processing.
.PP
If \fBmode\fR is \*(L"a\*(R", the file is created if it does not exist, or
opened if it does exist. Processing starts at the end of the file.
The \fBname\fR can be \fBstdout\fR, in which case the standard
output is readied for processing.
.PP
When a Funtools file is opened for writing or appending, a previously
opened Funtools reference
handle can be specified as the third argument. This handle
typically is associated with the input Funtools file that will be used
to generate the data for the output data.  When a reference file is
specified in this way, the output file will inherit the (extension)
header parameters from the input file:
.PP
.Vb 8
\&  Fun fun, fun2;
\&  ...
\&  /* open input file */
\&  if( !(fun = FunOpen(argv[1], "r", NULL)) )
\&    gerror(stderr, "could not FunOpen input file: %s\en", argv[1]);
\&  /* open the output FITS image, inheriting params from input */
\&  if( !(fun2 = FunOpen(argv[2], "w", fun)) )
\&    gerror(stderr, "could not FunOpen output file: %s\en", argv[2]);
.Ve
.PP
Thus, in the above example, the output \s-1FITS\s0 binary table file will
inherit all of the parameters associated with the input binary table
extension.
.PP
A file opened for writing with a 
Funtools reference handle also
inherits the selected columns (i.e. those columns chosen for
processing using the 
\&\fIFunColumnSelect()\fR routine)
from the reference file as its default columns. This makes it easy to
open an output file in such a way that the columns written to the
output file are the same as the columns read in the input file. Of
course, column selection can easily be tailored using the 
\&\fIFunColumnSelect()\fR routine.
In particular, it is easy to merge user-defined columns with the input
columns to generate a new file.  See the 
evmerge for a complete example.
.PP
In addition, when a
Funtools reference handle
is supplied in a \fIFunOpen()\fR call,
it is possible also to specify that all other extensions from the
reference file (other than the input extension being processed) should
be copied from the reference file to the output file. This is useful,
for example, in a case where you are processing a \s-1FITS\s0 binary table 
or image and you want to copy all of the other extensions to
the output file as well.  Copy of other extensions is controlled by
adding a \*(L"C\*(R" or \*(L"c\*(R" to the mode string of the 
\&\fIFunOpen()\fR call of the input
reference file.  If \*(L"C\*(R" is specified, then other extensions are
\&\fBalways\fR copied (i.e., copy is forced by the application).  If
\&\*(L"c\*(R" is used, then other extensions are copied if the user requests
copying by adding a plus sign \*(L"+\*(R" to the extension name in the bracket
specification.  For example, the \fBfuntable\fR program utilizes
\&\*(L"c\*(R" mode, giving users the option of copying all other extensions:
.PP
.Vb 6
\&  /* open input file -- allow user copy of other extensions */
\&  if( !(fun = FunOpen(argv[1], "rc", NULL)) )
\&    gerror(stderr, "could not FunOpen input file: %s\en", argv[1]);
\&  /* open the output FITS image, inheriting params from input */
\&  if( !(fun2 = FunOpen(argv[2], "w", fun)) )
\&    gerror(stderr, "could not FunOpen output file: %s\en", argv[2]);
.Ve
.PP
Thus, \fBfuntable\fR supports either of these command lines:
.PP
.Vb 4
\&  # copy only the EVENTS extension
\&  csh> funtable "test.ev[EVENTS,circle(512,512,10)]" foo.ev
\&  # copy ALL extensions
\&  csh> funtable "test.ev[EVENTS+,circle(512,512,10)]" foo.ev
.Ve
.PP
Use of a Funtools reference
handle implies that the input file is opened before the output
file.  However, it is important to note that if copy mode (\*(L"c\*(R" or \*(L"C\*(R")
is specified for the input file, the actual input file open is delayed
until just after the output file is opened, since the copy of prior
extensions to the output file takes place while Funtools is seeking to
the specified input extension.  This implies that the output file
should be opened before any I/O is done on the input file or else the
copy will fail.  Note also that the copy of subsequent extension will
be handled automatically by
\&\fIFunClose()\fR
if the output file is
closed before the input file. Alternatively, it can be done explicitly
by \fIFunFlush()\fR, but again, this
assumes that the input file still is open.
.PP
Upon success \fIFunOpen()\fR returns a
Fun handle that is used in subsequent Funtools calls. On error, \s-1NULL\s0
is returned.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
See funtools(7) for a list of Funtools help pages
