static char *EVENTS_PY="\n# load the funtools routines\n_libname = './libfuntools.so.1.0'\nlibfuntools=cdll.LoadLibrary(_libname)\nlibc=cdll.LoadLibrary(None)\n\n# region definitions\nimannulusi=libfuntools.imannulusi\nimboxi=libfuntools.imboxi\nimcirclei=libfuntools.imcirclei\nimellipsei=libfuntools.imellipsei\nimfieldi=libfuntools.imfieldi\nimlinei=libfuntools.imlinei\nimpiei=libfuntools.impiei\nimqtpiei=libfuntools.imqtpiei\nimpointi=libfuntools.impointi\nimpandai=libfuntools.impandai\nimnannulusi=libfuntools.imnannulusi\nimnboxi=libfuntools.imnboxi\nimnellipsei=libfuntools.imnellipsei\nimnpiei=libfuntools.imnpiei\nimpolygoni=libfuntools.impolygoni\nimvannulusi=libfuntools.imvannulusi\nimvboxi=libfuntools.imvboxi\nimvellipsei=libfuntools.imvellipsei\nimvpiei=libfuntools.imvpiei\nimvpointi=libfuntools.imvpointi\nimannulus=libfuntools.imannulus\nimbox=libfuntools.imbox\nimcircle=libfuntools.imcircle\nimellipse=libfuntools.imellipse\nimfield=libfuntools.imfield\nimline=libfuntools.imline\nimpie=libfuntools.impie\nimqtpie=libfuntools.imqtpie\nimpoint=libfuntools.impoint\nimpanda=libfuntools.impanda\nimnannulus=libfuntools.imnannulus\nimnbox=libfuntools.imnbox\nimnellipse=libfuntools.imnellipse\nimnpie=libfuntools.imnpie\nimpolygon=libfuntools.impolygon\nimvannulus=libfuntools.imvannulus\nimvbox=libfuntools.imvbox\nimvellipse=libfuntools.imvellipse\nimvpie=libfuntools.imvpie\nimvpoint=libfuntools.imvpoint\n\nevannulus=libfuntools.evannulus\nevbox=libfuntools.evbox\nevcircle=libfuntools.evcircle\nevellipse=libfuntools.evellipse\nevfield=libfuntools.evfield\nevline=libfuntools.evline\nevpie=libfuntools.evpie\nevqtpie=libfuntools.evqtpie\nevpoint=libfuntools.evpoint\nevnannulus=libfuntools.evnannulus\nevnbox=libfuntools.evnbox\nevnellipse=libfuntools.evnellipse\nevnpie=libfuntools.evnpie\nevpanda=libfuntools.evpanda\nevpolygon=libfuntools.evpolygon\nevvannulus=libfuntools.evvannulus\nevvbox=libfuntools.evvbox\nevvellipse=libfuntools.evvellipse\nevvpie=libfuntools.evvpie\nevvpoint=libfuntools.evvpoint\n\nevvcircle=libfuntools.evvannulus\nevncircle=libfuntools.evnannulus\nevcpanda=libfuntools.evpanda\n\nimvcirclei=libfuntools.imvannulusi\nimncirclei=libfuntools.imnannulusi\nimvcircle=libfuntools.imvannulus\nimncircle=libfuntools.imnannulus\nimcpandai=libfuntools.impandai\nimcpanda=libfuntools.impanda\n\n# from regions.h -- no idea what it is ...\nxsno=3\n\n#  ... but its important!\nmaxshapes=(nshape*(xsno+1))+1\n\n# ctypes struct definitions (taken from filter.h)\nclass filtmask(Structure):\n    _fields_ = [('region', c_int), ('y', c_int), ('xstart', c_int), ('xstop', c_int)]\n\nclass scanrec(Structure):\n    pass\n\n# this is how you add a forward pointer\nscanrec._fields_ = [ ('next', POINTER(scanrec)), ('x', c_int) ]\n\nclass shaperec(Structure):\n    _fields_ = [ ('init', c_int), ('ystart', c_double), ('ystop', c_double),	 ('scanlist', c_void_p), ('nv', c_int), ('xv', c_void_p), ('r1sq', c_double), ('r2sq', c_double), ('angl', c_double), ('sinangl', c_double), ('cosangl', c_double), ('cossq', c_double), ('sinsq', c_double), ('xradsq', c_double), ('yradsq', c_double), ('a', c_double), ('npt', c_int), ('pts', c_void_p), ('xonly', c_int), ('x1', c_double), ('x2', c_double), ('y1', c_double), ('invslope', c_double)]\n\nclass gfiltrec(Structure):\n    _fields_ = [('nshapes', c_int), ('maxshapes', c_int), ('shapes', POINTER(shaperec * maxshapes)), ('rid', c_int), ('usebinsiz', c_int), ('evsect', c_char_p), ('tlminx', c_double), ('tlminy', c_double), ('binsizx', c_double), ('binsizy', c_double), ('tloff', c_double), ('xmin', c_int), ('xmax', c_int), ('ymin', c_int), ('ymax', c_int), ('block', c_int), ('x0', c_int), ('x1', c_int), ('y0', c_int), ('y1', c_int), ('ybuf', POINTER(c_int)), ('x0s', POINTER(c_int)), ('x1s', POINTER(c_int)), ('nmask', c_int), ('maskdim', c_int), ('masks', POINTER(filtmask))]\n\n# taken from the code in evfilter.c that initializes the g struct\n# allocate shape record\nshapearr = (shaperec * maxshapes)()\n# allocate g record\ngrec = gfiltrec()\n# fill in g record\ngrec.nshapes = nshape\ngrec.maxshapes = maxshapes\ngrec.shapes = pointer(shapearr)\n# pointer to g record\ng=pointer(grec)\n\n# # processing loop\n# while True:\n#     rvals = ''\n#     buf = sys.stdin.read(4)\n#     if not buf: break\n#     vals = struct.unpack('=i', buf)\n#     nev = vals[0]/evsize\n#     for i in range(nev):\n#         evbuf = sys.stdin.read(evsize)\n#         rvals += struct.pack('=i', xfilter(evdef, evbuf))\n#     sys.stdout.write(struct.pack('=i', nev*4))\n#     sys.stdout.write(rvals)\n#     sys.stdout.flush()\n\n# processing loop\nobytes = 0\nwhile True:\n    # get byte count\n    nval = c_int(0)\n    if libc.read(0, byref(nval), 4) != 4: break\n    bytes = nval.value\n    nev =  bytes / evsize\n\n    # create a new data buffer, if necessary\n    if obytes != bytes:\n        evbuf = create_string_buffer(bytes)\n        pevbuf = addressof(evbuf)\n	rvals = (c_int * nev)()\n	obytes = bytes\n\n    # read data\n    if libc.read(0, evbuf, bytes) != bytes: break\n\n    # process data\n    ioff = 0\n    for i in range(nev):\n        rvals[i] = xfilter(evdef, evbuf[ioff:ioff+evsize])\n	ioff += evsize\n\n    # write result byte count and result data\n    nval = c_int(nev*4)\n    libc.write(1, byref(nval), 4)\n    libc.write(1, rvals, nval)\n";
