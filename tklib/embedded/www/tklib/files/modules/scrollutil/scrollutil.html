<!DOCTYPE html>
<html>
<head>
  <title>Scrollutil Programmer's Guide</title>

  <meta name="Author" content="Csaba Nemethi">
  <meta name="Keywords" content=
  "scrollarea, scrollsync, mouse wheel event, binding, event handling, scrolling, scrollable widget container, focus">

  <link rel="stylesheet" type="text/css" href="stylesheet.css">
</head>

<body>
  <div align="center">
    <h1>Scrollutil Programmer's Guide</h1>

    <h2>For Scrollutil Version 1.5</h2>

    <h3>by</h3>

    <h2>Csaba Nemethi</h2>

    <address>
      <a href="mailto:csaba.nemethi@t-online.de">csaba.nemethi@t-online.de</a>
    </address>
  </div>

  <hr>

  <h2 id="contents">Contents</h2>

  <h4><a href="#overview">Overview</a></h4>

  <ul>
    <li><a href="#ov_what">What Is Scrollutil?</a></li>

    <li><a href="#ov_get">How to Get It?</a></li>

    <li><a href="#ov_install">How to Install It?</a></li>

    <li><a href="#ov_use">How to Use It?</a></li>
  </ul>

  <h4><a href="#examples">Examples</a></h4>

  <ul>
    <li><a href="#ex_styleUtil">The Helper Script
    <code>styleUtil.tcl</code></a></li>

    <li><a href="#ex_ScrolledTablelist">A Scrolled tablelist Widget</a></li>

    <li><a href="#ex_ScrolledText">A Scrolled text Widget</a></li>

    <li><a href="#ex_SyncListboxes">Synchronizing Two listbox Widgets</a></li>

    <li><a href="#ex_SyncTablelists">Synchronizing Three tablelist
    Widgets</a></li>

    <li><a href="#ex_SuScrollableFrameDemo1">A Script Using a
    scrollutil::scrollableframe Widget</a></li>

    <li><a href="#ex_BwScrollableFrameDemo1">A Script Using a BWidget
    ScrollableFrame Widget</a></li>

    <li><a href="#ex_ScrolledFrameDemo1">A Script Using an
    iwidgets::scrolledframe Widget</a></li>

    <li><a href="#ex_SuScrollableFrameDemo2">A Script Using Two
    scrollutil::scrollableframe Widgets</a></li>

    <li><a href="#ex_BwScrollableFrameDemo2">A Script Using Two BWidget
    ScrollableFrame Widgets</a></li>

    <li><a href="#ex_ScrolledFrameDemo2">A Script Using Two
    iwidgets::scrolledframe Widgets</a></li>
  </ul>

  <div align="center">
    <p><a href="index.html">Start page</a></p>
  </div>

  <hr>

  <h2 id="overview">Overview</h2>

  <h3 id="ov_what">What Is Scrollutil?</h3>

  <p>Scrollutil is a library package for Tcl/Tk versions 8.0 or higher, written
  in pure Tcl/Tk code.&nbsp; It contains:</p>
  
  <ul>
    <li>the implementation of the <a href=
    "scrollarea.html"><b>scrollarea</b></a>, <a href=
    "scrollsync.html"><b>scrollsync</b></a>, and <a href=
    "scrollableframe.html"><b>scrollableframe</b></a> mega-widgets, including a
    general utility module for mega-widgets;</li>

    <li>the command <code><b><a href=
    "wheelEvent.html#add">scrollutil::addMouseWheelSupport</a></b></code>,
    which creates mouse wheel event bindings for a given binding tag.&nbsp;
    This command requires Tcl/Tk 8.4 or later;</li>

    <li>commands for <i>user-friendly</i> mouse wheel event handling in
    <b>scrollable widget containers</b> like scrollutil::scrollableframe,
    BWidget ScrollableFrame, and iwidgets::scrolledframe.&nbsp; These commands
    require Tcl/Tk versions 8.4 or higher on X11 and Mac OS X and Tk 8.6b2 or
    later on Windows;</li>

    <li>demo scripts illustrating the use of the Scrollutil package in
    connection with various scrollable widgets and the above-mentioned
    scrollable widget containers;</li>

    <li>this tutorial;</li>

    <li>reference pages in HTML format.</li>
  </ul>

  <p><b>The scrollutil::scrollarea mega-widget</b> greatly simplifies the
  creation of arbitrary scrolled widgets.&nbsp; It consists of a scrollable
  widget and two scrollbars connected with that widget.&nbsp; The display mode
  of each scrollbar can be <code>static</code>, <code>dynamic</code>, or
  <code>none</code>.&nbsp; This scrolled window implementation also supports
  the widgets that are scrollable in one direction only (e.g., entry and
  ttk::entry) and respects the header component and title columns of <a href=
  "https://www.nemethi.de/tablelist/">tablelist</a> widgets (this is freely
  configurable).</p>
  
  <p>The scrollutil::scrollarea widget is similar to BWidget ScrolledWindow and
  its snit-based equivalent widget::scrolledwindow, contributed by Jeffrey
  Hobbs and contained in tklib.&nbsp; The snit-based <a href=
  "http://web.tiscali.it/irrational/tcl/scrodget-2.1/">scrodget</a> package by
  Aldo Buratti and its TclOO-based equivalent <a href=
  "https://wiki.tcl-lang.org/page/A+Scrolled+Widget+implemented+with+TclOO">scrolledwidget</a>
  contributed by Johann Oberdorfer are further scrolled window implementations.
  However, <i>full</i> tablelist support is only provided by the scrollarea
  widget, which is free from external dependencies like BWidget, snit, or (for
  Tcl 8.5) TclOO.&nbsp; It is also free from the <a href=
  "https://wiki.tcl-lang.org/page/Scroll+bars+that+appear+only+when+needed">shimmering
  problem in connection with text widgets</a>, which the above-mentioned
  scrolled window implementations either share with the autoscroll package
  (contained in tklib) or circumvent in a suboptimal way.</p>

  <p><b>The scrollutil::scrollsync mega-widget</b> is designed for scrolling
  several widgets simultaneously.&nbsp; Whenever the horizontal/vertical
  position of the view in the window of one of its widgets changes, the view in
  the windows of all the other widgets is automatically adjusted accordingly,
  thus making sure that the view's position in these windows is kept in
  sync.&nbsp; This mega-widget is horizontally and vertically scrollable, hence
  it can be embedded into a scrollutil::scrollarea widget via the latter's
  <code>setwidget</code> subcommand.</p>

  <p><b>The scrollutil::scrollableframe mega-widget</b> is a scrollable widget
  container.&nbsp; It contains a content frame, whose dimensions are typically
  larger than those of the widget itself.&nbsp; Arbitrary regions of this frame
  can be brought into view by scrolling, and the widget also provides a command
  for making individual widgets contained in the content frame visible in the
  scrollableframe window.</p>
  
  <p>The scrollutil::scrollableframe widget is similar to BWidget
  ScrollableFrame and iwidgets::scrolledframe.&nbsp; However, unlike these
  widgets, which use a canvas for scrolling the content frame, it adjusts the
  view with the aid of the <code><b>place</b></code> geometry manager, just
  like the <code>scrolledframe::scrolledframe</code> command of the
  Scrolledframe package by Maurice Bredelet (ulis) and its optimized and
  enhanced version contributed by Keith Nash.&nbsp; For details on these
  commands see the wiki page</p>

  <blockquote>
    <address>
      <a href=
      "https://wiki.tcl-lang.org/page/A+scrolled+frame">https://wiki.tcl-lang.org/page/A+scrolled+frame</a>
    </address>
  </blockquote>

  <p>Scrollutil's canvas-free approach is more lightweight and integrates
  better in applications that use tile widgets.</p>

  <p>From the point of view of <b>the commands related to mouse wheel event
  handling</b> provided by the Scrollutil package, the scrollability of a
  widget or widget container window means that the associated Tcl command
  supports the&nbsp; <code>xview scroll <i>number</i> units</code>&nbsp;
  and&nbsp; <code>yview scroll <i>number</i> units</code>&nbsp;
  subcommands.&nbsp; The reason for requiring at least Tk version 8.6b2 on
  Windows for the commands related to scrollable widget containers is that in
  earlier Tk versions on this platform the mouse wheel events were sent to the
  widget having the focus rather than to the one under the pointer.</p>

  <p>To make use of the user-friendly mouse wheel event handling via the
  Scrollutil package, follow the steps below:</p>

  <ul>
    <li>Create mouse wheel event bindings for the binding tag
    <code>"all"</code> or for the toplevel widgets (including <code>"."</code>)
    having scrollable widget containers, by invoking the <code><a href=
    "wheelEvent.html#create">scrollutil::createWheelEventBindings</a></code>
    command.&nbsp; In addition, register your scrollable widget containers for
    scrolling via these bindings with the aid of the <code><a href=
    "wheelEvent.html#enable">scrollutil::enableScrollingByWheel</a></code>
    command.&nbsp; The above-mentioned bindings handle the mouse wheel events
    by scrolling the (innermost) registered scrollable widget container that is
    an ascendant of the widget under the pointer and is contained in the
    latter's toplevel.</li>

    <li class="tm">Invoke the <code><a href=
    "wheelEvent.html#adapt">scrollutil::adaptWheelEventHandling</a></code>
    command for those widgets contained in registered scrollable widget
    containers that have mouse wheel event (class) bindings.&nbsp; This step
    eliminates the annoying and often dangerous double-handling effect, by
    modifying the mouse wheel event handling as follows:&nbsp; If the focus is
    on the widget under the pointer then the mouse wheel events will be handled
    by the (class bindings of the) widget only, otherwise by the bindings
    created with the <code>scrollutil::createWheelEventBindings</code>
    command.&nbsp; Without this step the mouse wheel events would scroll both
    the listbox, text, ttk::treeview, or tablelist widget under the pointer
    <i>and</i> the widget container to whose descendants the latter belongs, or
    they would select the next/previous value in the ttk::combobox or
    ttk::spinbox under the pointer <i>in addition to</i> scrolling the widget
    container.</li>

    <li class="tm">For some widgets it can be desirable to make the focus check
    within this modified event handling less restrictive.&nbsp; For example, if
    the widget under the pointer is an entry component of a <a href=
    "https://www.nemethi.de/mentry/">mentry</a> of type <code>"Date"</code>,
    <code>"Time"</code>, <code>"DateTime"</code>, <code>"IPAddr"</code>, or
    <code>"IPv6Addr"</code> and the focus is on any of its siblings, then the
    mouse wheel events sent to this entry should be handled by the entry widget
    itself rather than scrolling the widget container that is an ascendant of
    the mentry.&nbsp; The <code><a href=
    "wheelEvent.html#setFocusCkWin">scrollutil::setFocusCheckWindow</a></code>
    command covers exactly cases like this.</li>
  </ul>

  <p>The mouse wheel event handling with the aid of the Scrollutil package was
  also tested to work with the <code>scrolledframe::scrolledframe</code>
  command of the Scrolledframe package by Maurice Bredelet (ulis) and its
  optimized and enhanced version contributed by Keith Nash, as well as with the
  <code>sframe</code> command implemented by Paul Walton.&nbsp; For details on
  these commands (which provide further implementations of scrollable widget
  containers) see the above-mentioned wiki page.</p>

  <h3 id="ov_get">How to Get It?</h3>

  <p>Scrollutil is available for free download from the Web page</p>

  <blockquote>
    <address>
      <a href="https://www.nemethi.de">https://www.nemethi.de</a>
    </address>
  </blockquote>

  <p>The distribution file is <code>scrollutil1.5.tar.gz</code> for UNIX and
  <code>scrollutil1_5.zip</code> for Windows.&nbsp; These files contain the
  same information, except for the additional carriage return character
  preceding the linefeed at the end of each line in the text files for
  Windows.</p>

  <p>Scrollutil is also included in tklib, which has the address</p>

  <blockquote>
    <address>
      <a href="https://core.tcl.tk/tklib">https://core.tcl.tk/tklib</a>
    </address>
  </blockquote>

  <h3 id="ov_install">How to Install It?</h3>

  <p>Install the package as a subdirectory of one of the directories given by
  the <code>auto_path</code> variable.&nbsp; For example, you can install it as
  a directory at the same level as the Tcl and Tk script libraries.&nbsp; The
  locations of these library directories are given by the
  <code>tcl_library</code> and <code>tk_library</code> variables,
  respectively.</p>

  <p>To install Scrollutil <i>on UNIX</i>, <code>cd</code> to the desired
  directory and unpack the distribution file
  <code>scrollutil1.5.tar.gz</code>:</p>

  <blockquote>
    <pre>
gunzip -c scrollutil1.5.tar.gz | tar -xf -
</pre>
  </blockquote>

  <p>On most UNIX systems this can be replaced with</p>

  <blockquote>
    <pre>
tar -zxf scrollutil1.5.tar.gz
</pre>
  </blockquote>

  <p>Both commands will create a directory named <code>scrollutil1.5</code>,
  with the subdirectories <code>demos</code>, <code>doc</code>, and
  <code>scripts</code>.</p>

  <p><i>On Windows</i>, use WinZip or some other program capable of unpacking
  the distribution file <code>scrollutil1_5.zip</code> into the directory
  <code>scrollutil1.5</code>, with the subdirectories <code>demos</code>,
  <code>doc</code>, and <code>scripts</code>.</p>

  <p>Notice that in tklib the Scrollutil <code>demos</code> directory is
  replaced with the subdirectory <code>scrollutil</code> of the
  <code>examples</code> directory.&nbsp; Please take this into account when
  reading the <a href="#examples">examples</a> below.</p>

  <h3 id="ov_use">How to Use It?</h3>

  <p>The Scrollutil distribution provides two packages, called
  <b>Scrollutil</b> and <b>Scrollutil_tile</b>.&nbsp; The main difference
  between the two is that Scrollutil_tile enables the tile-based,
  theme-specific appearance of scrollarea, scrollsync, and scrollableframe
  widgets; this package requires Tcl/Tk 8.4 or higher and tile 0.6 or
  higher.&nbsp; It is not possible to use both packages in one and the same
  application, because both are implemented in the same <code>scrollutil</code>
  namespace and provide identical commands.</p>

  <p>To be able to access the commands and variables defined in the package
  Scrollutil, your scripts must contain one of the lines</p>

  <blockquote>
    <pre>
package require scrollutil ?<i>version</i>?
package require Scrollutil ?<i>version</i>?
</pre>
  </blockquote>

  <p>You can use either one of the two statements above because the file
  <code>scrollutil.tcl</code> contains both lines</p>

  <blockquote>
    <pre>
package provide scrollutil ...
package provide Scrollutil ...
</pre>
  </blockquote>

  <p>Likewise, to be able to access the commands and variables defined in the
  package Scrollutil_tile, your scripts must contain one of the lines</p>

  <blockquote>
    <pre>
package require scrollutil_tile ?<i>version</i>?
package require Scrollutil_tile ?<i>version</i>?
</pre>
  </blockquote>

  <p>Again, you can use either one of the two statements above because the file
  <code>scrollutil_tile.tcl</code> contains both lines</p>

  <blockquote>
    <pre>
package provide scrollutil_tile ...
package provide Scrollutil_tile ...
</pre>
  </blockquote>

  <p>You are free to remove one of these two lines from
  <code>scrollutil.tcl</code> and <code>scrollutil_tile.tcl</code>,
  respectively, if you want to prevent the corresponding packages from making
  themselves known under two different names each.&nbsp; Of course, by doing so
  you restrict the argument of&nbsp; <code>package require</code>&nbsp; to a
  single name.</p>

  <p>Since the packages Scrollutil and Scrollutil_tile are implemented in the
  <code>scrollutil</code> namespace, you must either invoke the</p>

  <blockquote>
    <pre>
namespace import scrollutil::<i>pattern</i> ?scrollutil::<i>pattern ...</i>?
</pre>
  </blockquote>

  <p>command to import the <i>procedures</i> you need, or use qualified names
  like <code>scrollutil::scrollarea</code>.&nbsp; In the <a href=
  "#examples">examples</a> below we have chosen the latter approach.</p>

  <p>To access Scrollutil <i>variables</i>, you <i>must</i> use qualified
  names.&nbsp; There are only three Scrollutil variables that are designed to
  be accessed outside the namespace <code>scrollutil</code>:</p>

  <ul>
    <li>The variable <code>scrollutil::version</code> holds the current version
    number of the Scrollutil package.</li>

    <li>The variable <code>scrollutil::library</code> holds the location of the
    Scrollutil installation directory.</li>

    <li>The read-only variable <code>scrollutil::usingTile</code> has the value
    <code>0</code> in the package Scrollutil and the value <code>1</code> in
    Scrollutil_tile.</li>
  </ul>

  <p>The Scrollutil_tile package checks whether the required Tk and tile
  versions are present, by executing the commands</p>

  <blockquote>
    <pre>
package require Tk 8.4
if {$::tk_version &lt; 8.5 || [regexp {^8\.5a[1-5]$} $::tk_patchLevel]} {
    package require tile 0.6
}
</pre>
  </blockquote>

  <p>The second command above reflects the fact that, beginning with Tk 8.5a6,
  tile is integrated into the Tk core and therefore it should only be loaded
  explicitly when using an earlier Tk version.</p>

  <div align="center">
    <p><a href="#contents">Contents</a>&nbsp;&nbsp;&nbsp;&nbsp; <a href=
    "index.html">Start page</a></p>
  </div>

  <hr>

  <h2 id="examples">Examples</h2>

  <h3 id="ex_styleUtil">The Helper Script <code>styleUtil.tcl</code></h3>

  <p>All the examples in the <code>demos</code> directory use tile (ttk)
  widgets and contain the line</p>

  <blockquote>
    <pre>
source styleUtil.tcl
</pre>
  </blockquote>

  <p>The script <code>styleUtil.tcl</code> patches a few ttk widget styles and
  defines the style <code>Small.Toolbutton</code>.&nbsp; In addition, on X11 it
  sets the theme to a slightly patched variant of the <code>clam</code>
  theme (having smaller ttk::button widgets as well as ttk::treeview and
  tablelist headers).</p>
  
  <p>The patch for the style <code>TCombobox</code> makes sure that the
  (readonly) ttk::combobox widgets of the themes <code>alt</code>,
  <code>clam</code>, and <code>default</code> will show whether they have the
  focus.&nbsp; This basic requirement, which makes the keyboard navigation more
  user-friendly, is already fulfilled by the themes <code>vista</code>,
  <code>xpnative</code>, and <code>aqua</code>.</p>

  <p>The ttk::button widgets of the style <code>Small.Toolbutton</code> created
  by the procedure <code>createToolbutton</code>, implemented in this helper
  script, will appear raised when they have the focus.&nbsp; Again, this makes
  the keyboard navigation more user-friendly.</p>

  <h3 id="ex_ScrolledTablelist">A Scrolled tablelist Widget</h3>

  <p>This example shows how you can greatly simplify the creation of a scrolled
  tablelist by using a <a href="scrollarea.html">scrollarea</a> widget.</p>

  <p>The file <code>ScrolledTablelist1.tcl</code> in the <code>demos</code>
  directory creates a horizontally and vertically scrolled tablelist widget
  having two header rows and one title column, and manages the two scrollbars
  in such a way that the vertical scrollbar appears below the tablelist's
  header and the horizontal one starts to the right of the widget's title
  column area:</p>

  <blockquote>
    <img src="ScrolledTablelist.png" alt="ScrolledTablelist" width="480"
    height="337">
  </blockquote>

  <p>The script achieves these requirements using traditional scrollbar
  management, which is shown below in <span class="red">red</span> color:</p>

  <blockquote>
    <pre>
package require Tk 8.5
package require tablelist_tile 6.3
source styleUtil.tcl

wm title . "Scrolled Tablelist"

<span class="cmt">#
# Create the tablelist and the scrollbars as children
# of a frame having -borderwidth 1 and -relief sunken
#</span>
set f   [ttk::frame .f]
set frm [ttk::frame $f.frm <span class="red">-borderwidth 1 -relief sunken</span>]
set tbl $frm.tbl
<span class="red">set vsb $frm.vsb
set hsb $frm.hsb</span>
tablelist::tablelist $tbl ... <span class="red">-borderwidth 0</span> \
<span class="red">    -xscrollcommand [list $hsb set] -yscrollcommand [list $vsb set]</span>
. . .
<span class="red">ttk::scrollbar $vsb -orient vertical   -command [list $tbl yview]
ttk::scrollbar $hsb -orient horizontal -command [list $tbl xview]</span>

. . .

<span class="cmt">#
# Manage the widgets within the frame
#</span>
<span class="red">grid $tbl -row 0 -rowspan 2 -column 0 -columnspan 2 -sticky news
if {[tk windowingsystem] eq "win32"} {
    grid $vsb -row 0 -rowspan 2 -column 2 -sticky ns
} else {
    grid [$tbl cornerpath] -row 0 -column 2 -sticky ew
    grid $vsb              -row 1 -column 2 -sticky ns
}
grid [$tbl cornerpath -sw] -row 2 -column 0 -sticky ns
grid $hsb                  -row 2 -column 1 -sticky ew
grid rowconfigure    $frm 1 -weight 1
grid columnconfigure $frm 1 -weight 1</span>

<span class="cmt">#
# Manage the frame
#</span>
pack $frm -expand yes -fill both -padx 10 -pady 10
pack $f   -expand yes -fill both
</pre>
  </blockquote>

  <p>The file <code>ScrolledTablelist2.tcl</code> in the <code>demos</code>
  directory replaces the rather technical code above with just a few lines
  (shown below in <span class="red">red</span> color), by embedding the
  tablelist into a scrollarea widget.&nbsp; It requires Tablelist version 6.5,
  which is needed so the <code><a href=
  "scrollarea.html#respectheader">-respectheader</a></code> and <code><a href=
  "scrollarea.html#respecttitlecolumns">-respecttitlecolumns</a></code>
  scrollarea options can work as expected (for earlier Tablelist versions these
  options are silently ignored).&nbsp; As a further benefit, the scrollbars
  created with this method will have the default display mode
  <code>dynamic</code>.</p>

  <blockquote>
    <pre>
package require Tk 8.5
package require tablelist_tile 6.5
<span class="red">package require scrollutil_tile</span>
source styleUtil.tcl

wm title . "Scrolled Tablelist"

<span class="cmt">#
# Create the tablelist within a scrollarea
#</span>
set f  [ttk::frame .f]
<span class="red">set sa [scrollutil::scrollarea $f.sa]</span>
set tbl $sa.tbl
tablelist::tablelist $tbl ...
. . .
<span class="red">$sa setwidget $tbl</span>

. . .

<span class="cmt">#
# Manage the scrollarea
#</span>
pack $sa -expand yes -fill both -padx 10 -pady 10
pack $f  -expand yes -fill both
</pre>
  </blockquote>

  <h3 id="ex_ScrolledText">A Scrolled text Widget</h3>

  <p>The file <code>ScrolledText.tcl</code> in the <code>demos</code> directory
  shows how the <a href="scrollarea.html">scrollarea</a> widget circumvents the
  potential shimmering effect in connection with text widgets.</p>

  <blockquote>
    <img src="ScrolledText.png" alt="ScrolledText" width="401" height="338">
  </blockquote>

  <p>Here is the relevant code, in which the lines related to the scrollarea
  widget are shown in <span class="red">red</span> color:</p>

  <blockquote>
    <pre>
<span class="red">package require scrollutil_tile</span>
source styleUtil.tcl

wm title . "Scrolled Text"

<span class="cmt">#
# Create a text widget within a scrollarea
#</span>
set f  [ttk::frame .f]
<span class="red">set sa [scrollutil::scrollarea $f.sa -lockinterval 10]</span>
set txt [text $sa.txt -font TkFixedFont -width 49 -height 12 \
         -spacing1 2 -spacing3 2 -wrap none]
<span class="red">$sa setwidget $txt</span>

<span class="cmt">#
# Populate the text widget and set the background color of line #25 to red
#</span>
for {set i 1} {$i <= 30} {incr i} {
    set j [expr {2*$i}]
    $txt insert end [string repeat x $j]\n
}
$txt delete 30.end
$txt tag configure bgRed -background red
$txt tag add bgRed 25.0 25.end

. . .

<span class="cmt">#
# Manage the scrollarea
#</span>
pack $sa -expand yes -fill both -padx 10 -pady 10
pack $f  -expand yes -fill both

<span class="cmt">#
# Adjust the vertical view in the text window
# so that line #25 becomes the bottom line
#</span>
tkwait visibility $txt
after 100 [list $txt yview 14.0]
</pre>
  </blockquote>

  <p>The script creates a text widget <code>$txt</code> embedded into a
  scrollarea, populates it with 30 lines, and adjusts the vertical view in the
  text window so that line #25 becomes the bottom line.&nbsp; This line has 50
  characters, hence it doesn't fit completely into the window, whose width is
  49 characters.&nbsp; Consequently, the command&nbsp; <code>$txt
  xview</code>&nbsp; will return the list&nbsp; <code>{0.0 0.98}</code>,&nbsp;
  hence the scrollarea's horizontal scrollbar will be mapped and will obscure
  most part of the bottom line.&nbsp; Since this line has <code>red</code>
  background, it is easy to see how much of it sticks out above the upper edge
  of the scrollbar.</p>

  <p>Let's analyze what happens if the text widget's height is decreased by
  dragging the main window's upper or lower edge, just until the red pixels get
  obscured by the horizontal scrollbar.&nbsp; After performing this action,
  line #25 is completely out of view and the new bottom line is line #24, which
  has 48 characters, hence the command&nbsp; <code>$txt xview</code>&nbsp; will
  return&nbsp; <code>{0.0 1.0}</code>.&nbsp; Normally, this would cause the
  horizontal scrollbar to be unmapped.&nbsp; However, that would make line #25
  to the bottom line, thus causing the horizontal scrollbar to be mapped
  again.&nbsp; This time the scrollbar would completely obscure this line,
  which would result in line #24 to become the bottom line, which would cause
  the scrollbar to be unmapped again, and so on.&nbsp; In other words, the
  horizontal scrollbar would get mapped and unmapped in an endless loop, giving
  rise to an annoying flickering effect.&nbsp; The built-in locking mechanism
  of the scrollarea widget guards against such potential endless loops.&nbsp;
  To make sure that the locking will work as expected, we have set the
  <code><a href="scrollarea.html#lockinterval">-lockinterval</a></code>
  scrollarea option to <code>10</code> (recall that the default value is
  <code>1</code>).</p>

  <h3 id="ex_SyncListboxes">Synchronizing Two listbox Widgets</h3>

  <p>The file <code>SyncListboxes.tcl</code> in the <code>demos</code>
  directory creates two listboxes within a <a href=
  "scrollsync.html">scrollsync</a> widget, which in turn is embedded into a
  <a href="scrollarea.html">scrollarea</a>.</p>

  <blockquote>
    <img src="SyncListboxes.png" alt="SyncListboxes" width="320" height="305">
  </blockquote>

  <p>Here is the relevant code, in which the lines related to the scrollarea
  and scrollsync widgets are shown in <span class="red">red</span> color:</p>

  <blockquote>
    <pre>
<span class="red">package require scrollutil_tile</span>
source styleUtil.tcl

wm title . "European Countries"

. . .

set f  [ttk::frame .f]

. . .

<span class="cmt">#
# Create a scrollsync widget within a scrollarea
#</span>
<span class="red">set sa [scrollutil::scrollarea $f.sa]
set ss [scrollutil::scrollsync $sa.ss]
$sa setwidget $ss</span>

<span class="cmt">#
# Populate the scrollsync widget with two listboxes
#</span>

. . .

set lb1 [listbox $ss.lb1 -activestyle none -highlightthickness 0 -width 16]
set lb2 [listbox $ss.lb2 -activestyle none -highlightthickness 0 -width 16]
<span class="red">$ss setwidgets [list $lb1 $lb2]</span>

. . .

grid $lb1 $lb2 -sticky news -padx {0 2}
grid rowconfigure    $ss 0 -weight 1
grid columnconfigure $ss 0 -weight 1
grid columnconfigure $ss 1 -weight 1

. . .

pack $sa -side top -expand yes -fill both -padx 10 -pady {2 10}
pack $f  -expand yes -fill both

. . .
</pre>
  </blockquote>

  <h3 id="ex_SyncTablelists">Synchronizing Three tablelist Widgets</h3>

  <p>The file <code>SyncTablelists.tcl</code> in the <code>demos</code>
  directory creates three tablelists within a <a href=
  "scrollsync.html">scrollsync</a> widget, which in turn is embedded into a
  <a href="scrollarea.html">scrollarea</a>.</p>

  <blockquote>
    <img src="SyncTablelists.png" alt="SyncTablelists" width="548" height=
    "326">
  </blockquote>

  <p>The relevant code is similar to the one shown in the <a href=
  "#ex_SyncListboxes">previous example</a>:</p>

  <blockquote>
    <pre>
package require tablelist_tile
<span class="red">package require scrollutil_tile</span>
source styleUtil.tcl

wm title . "Synchronized Tablelists"

. . .

set f  [ttk::frame .f]

. . .

<span class="cmt">#
# Create a scrollsync widget within a scrollarea
#</span>
<span class="red">set sa [scrollutil::scrollarea $f.sa]
set ss [scrollutil::scrollsync $sa.ss]
$sa setwidget $ss</span>

<span class="cmt">#
# Populate the scrollsync widget with three tablelists
#</span>

option add *Tablelist.stripeBackground  #f0f0f0

for {set n 1; set colWidth 40} {$n <= 3} {incr n; incr colWidth 20} {
    set tbl [tablelist::tablelist $ss.tbl$n \
             -columns [list 0 "Column 0" left  $colWidth "Column 1" left]]
    set tbl$n $tbl

    for {set i 0} {$i < 40} {incr i} {
        $tbl insert end [list "cell $i,0" "cell $i,1"]
    }
}
<span class="red">$ss setwidgets [list $tbl1 $tbl2 $tbl3]</span>

grid $tbl1 $tbl2 $tbl3 -sticky news -padx {0 2}
grid rowconfigure    $ss 0 -weight 1
grid columnconfigure $ss 0 -weight 1
grid columnconfigure $ss 1 -weight 1
grid columnconfigure $ss 2 -weight 1

. . .

pack $sa -side top -expand yes -fill both -padx 10 -pady {2 10}
pack $f  -expand yes -fill both

. . .
</pre>
  </blockquote>

  <p>Notice that column #1 of the three tablelist widgets is 40, 60, and 80
  characters wide, respectively.&nbsp; For this reason, when scrolling
  horizontally to the right, the left table's view will reach its horizontal
  end position first, then that of the midde table, and as last one the view of
  the right table.</p>

  <h3 id="ex_SuScrollableFrameDemo1">A Script Using a
  scrollutil::scrollableframe Widget</h3>

  <p>The file <code>SuScrollableFrmDemo1.tcl</code> in the <code>demos</code>
  directory creates a <a href=
  "scrollableframe.html">scrollutil::scrollableframe</a> widget embedded into a
  <a href="scrollarea.html">scrollarea</a>, creates mouse wheel event bindings
  for the binding tag <code>"all"</code> with the aid of the <code><a href=
  "wheelEvent.html#create">scrollutil::createWheelEventBindings</a></code>
  command, and invokes the <code><a href=
  "wheelEvent.html#enable">scrollutil::enableScrollingByWheel</a></code>
  command for this scrollableframe, thus registering the latter for scrolling
  by these bindings.&nbsp; After that it populates the content frame of the
  scrollableframe with ttk::label widgets displaying the names of the European
  countries, ttk::combobox widgets for selecting the corresponding capital
  cities, and ttk::button widgets of the style <code>Small.Toolbutton</code>
  (created by using the procedure <code>createToolbutton</code>, implemented in
  the file <code><a href="#ex_styleUtil">styleUtil.tcl</a></code>) for the less
  patient users, displaying the text "Resolve".</p>

  <blockquote>
    <img src="ScrollableFrmDemo1.png" alt="ScrollableFrmDemo1" width="407"
    height="373">
  </blockquote>

  <p>Here is the relevant code:</p>

  <blockquote>
    <pre>
<span class="red">package require scrollutil_tile</span>
source styleUtil.tcl

wm title . "European Capitals Quiz"

<span class="cmt">#
# Create a scrollableframe within a scrollarea
#</span>
set f  [ttk::frame .f]
<span class="red">set sa [scrollutil::scrollarea $f.sa]
set sf [scrollutil::scrollableframe $sa.sf]
$sa setwidget $sf</span>

<span class="cmt">#
# Create mouse wheel event bindings for the binding tag "all" and
# register the scrollableframe for scrolling by these bindings
#</span>
<span class="red">scrollutil::createWheelEventBindings all
scrollutil::enableScrollingByWheel $sf</span>

<span class="cmt">#
# Get the content frame and populate it
#</span>

<span class="red">set cf [$sf contentframe]</span>

set countryList {
    Albania Andorra Austria Belarus Belgium "Bosnia and Herzegovina" Bulgaria
    . . .
}
set capitalList {
    Tirana "Andorra la Vella" Vienna Minsk Brussels Sarajevo Sofia
    . . .
}

. . .

set capitalList [lsort $capitalList]

. . .

set row 0
foreach country $countryList {
    . . .

    set w [ttk::combobox $cf.cb$row -state readonly -width 14 \
           -values $capitalList]
    . . .

    <span class="cmt">#
    # Make the keyboard navigation more user-friendly
    #</span>
    bind $w &lt;&lt;TraverseIn&gt;&gt; [list <span class="red">$sf see %W</span>]

    <span class="cmt">#
    # Adapt the handling of the mouse wheel events for the ttk::combobox widget
    #</span>
    <span class="red">scrollutil::adaptWheelEventHandling $w</span>

    . . .

    incr row
}

. . .
</pre>
  </blockquote>

  <p>We make the keyboard navigation more user-friendly with the aid of the
  <code><a href="scrollableframe.html#see">see</a></code> subcommand of the
  scrollableframe widget when handling the
  <code>&lt;&lt;TraverseIn&gt;&gt;</code> virtual event for the ttk::combobox
  and (not shown above) ttk::button widgets.&nbsp; In addition, we invoke the
  <code><a href=
  "wheelEvent.html#adapt">scrollutil::adaptWheelEventHandling</a></code>
  command for every ttk::combobox widget, which is needed for a user-friendly
  event handling, being that this widget has built-in bindings for the mouse
  wheel events.&nbsp; Due to this command, the mouse wheel events over one of
  the ttk::combobox widgets will only select the next/previous capital city if
  the widget has the focus, otherwise they will scroll the scrollableframe.</p>

  <p>With this script you can also test the scanning in the
  scrollableframe:&nbsp; If you press mouse button 1 over a free space of the
  scrollableframe window then the cursor will take on the shape of a pointing
  hand, and by draggging the mouse, the content frame will drag at high speed
  through the window, in the direction the mouse moves.</p>

  <h3 id="ex_BwScrollableFrameDemo1">A Script Using a BWidget ScrollableFrame
  Widget</h3>

  <p>The file <code>BwScrollableFrmDemo1.tcl</code> in the <code>demos</code>
  directory creates a BWidget ScrollableFrame embedded into a <a href=
  "scrollarea.html">scrollarea</a> widget, creates mouse wheel event bindings
  for the binding tag <code>"all"</code> with the aid of the <code><a href=
  "wheelEvent.html#create">scrollutil::createWheelEventBindings</a></code>
  command, and invokes the <code><a href=
  "wheelEvent.html#enable">scrollutil::enableScrollingByWheel</a></code>
  command for this ScrollableFrame, thus registering the latter for scrolling
  by these bindings.&nbsp; After that it populates the content frame of the
  ScrollableFrame with the same widgets as
  <code>SuScrollableFrmDemo1.tcl</code> in the <a href=
  "#ex_SuScrollableFrameDemo1">previous example</a>.</p>

  <p>Here is the relevant code:</p>

  <blockquote>
    <pre>
package require BWidget
Widget::theme yes
<span class="red">package require scrollutil_tile</span>
source styleUtil.tcl

wm title . "European Capitals Quiz"

<span class="cmt">#
# Create a ScrollableFrame within a scrollarea
#</span>
set f  [ttk::frame .f]
<span class="red">set sa [scrollutil::scrollarea $f.sa]</span>
set sf [ScrollableFrame $sa.sf]
<span class="red">$sa setwidget $sf</span>

. . .

<span class="cmt">#
# Create mouse wheel event bindings for the binding tag "all" and
# register the ScrollableFrame for scrolling by these bindings
#</span>
<span class="red">scrollutil::createWheelEventBindings all
scrollutil::enableScrollingByWheel $sf</span>

<span class="cmt">#
# Get the content frame and populate it
#</span>

set cf [$sf getframe]

set countryList {
    Albania Andorra Austria Belarus Belgium "Bosnia and Herzegovina" Bulgaria
    . . .
}
set capitalList {
    Tirana "Andorra la Vella" Vienna Minsk Brussels Sarajevo Sofia
    . . .
}

. . .

set capitalList [lsort $capitalList]

. . .

set row 0
foreach country $countryList {
    . . .

    set w [ttk::combobox $cf.cb$row -state readonly -width 14 \
           -values $capitalList]
    . . .

    <span class="cmt">#
    # Make the keyboard navigation more user-friendly
    #</span>
    bind $w &lt;&lt;TraverseIn&gt;&gt; [list $sf see %W]

    <span class="cmt">#
    # Adapt the handling of the mouse wheel events for the ttk::combobox widget
    #</span>
    <span class="red">scrollutil::adaptWheelEventHandling $w</span>

    . . .

    incr row
}

. . .
</pre>
  </blockquote>

  <h3 id="ex_ScrolledFrameDemo1">A Script Using an iwidgets::scrolledframe
  Widget</h3>

  <p>The file <code>ScrolledFrmDemo1.tcl</code> in the <code>demos</code>
  directory creates an iwidgets::scrolledframe widget, creates mouse wheel
  event bindings for the binding tag <code>"all"</code> with the aid of the
  <code><a href=
  "wheelEvent.html#create">scrollutil::createWheelEventBindings</a></code>
  command, and invokes the <code><a href=
  "wheelEvent.html#enable">scrollutil::enableScrollingByWheel</a></code>
  command for this scrolledframe, thus registering the latter for scrolling by
  these bindings.&nbsp; After that it populates the content frame of the
  scrolledframe with the same widgets as <code>SuScrollableFrmDemo1.tcl</code>
  and <code>BwScrollableFrmDemo1.tcl</code> in the two previous examples.</p>

  <p>Here is the relevant code:</p>

  <blockquote>
    <pre>
if {[catch {package require iwidgets} result1] != 0 &&
    [catch {package require Iwidgets} result2] != 0} {
    error "$result1; $result2"
}
source scrolledwidgetPatch.itk                  ;<span class="cmt"># adds ttk::scrollbar widgets</span>
<span class="red">package require scrollutil_tile</span>
source styleUtil.tcl

wm title . "European Capitals Quiz"

. . .

<span class="cmt">#
# Create a scrolledframe
#</span>
set f  [ttk::frame .f]
set sf [iwidgets::scrolledframe $f.sf -borderwidth 1 -relief sunken \
        -scrollmargin 0]
. . .

<span class="cmt">#
# Create mouse wheel event bindings for the binding tag "all"
# and register the scrolledframe for scrolling by these bindings
#</span>
<span class="red">scrollutil::createWheelEventBindings all
scrollutil::enableScrollingByWheel $sf</span>

<span class="cmt">#
# Get the content frame and populate it
#</span>

set cf [$sf childsite]
. . .

<i>&lt;exactly as in the two previous examples, except the stuff related to keyboard navigation&gt;</i>

. . .
</pre>
  </blockquote>

  <p>The code related to keyboard navigation is not present in this example,
  because the iwidgets::scrolledframe widget doesn't provide a <code>see</code>
  subcommand.</p>

  <h3 id="ex_SuScrollableFrameDemo2">A Script Using Two
  scrollutil::scrollableframe Widgets</h3>

  <p>The script <code>SuScrollableFrmDemo2.tcl</code> in the <code>demos</code>
  directory creates a <a href=
  "scrollableframe.html">scrollutil::scrollableframe</a> widget embedded into a
  <a href="scrollarea.html">scrollarea</a> and then <code>source</code>s the
  script <code>SuScrollableFrmContent.tcl</code>, which populates the content
  frame of the scrollableframe with the following widgets:</p>

  <ul>
    <li>a series of ttk::label widgets;</li>

    <li>a scrolled text widget <code>$txt</code> within a scrollarea;</li>

    <li>a scrolled listbox widget <code>$lb</code> within a scrollarea;</li>

    <li>a ttk::combobox widget <code>$cb</code>;</li>

    <li>a ttk::spinbox widget <code>$sb</code>;</li>

    <li>a ttk::entry widget <code>$e</code>;</li>

    <li>a ttk::separator widget;</li>

    <li>a mentry widget <code>$me</code> of type <code>"Date"</code>;</li>

    <li>a scrolled tablelist widget <code>$tbl</code> within a scrollarea;</li>

    <li>a scrolled ttk::treeview widget <code>$tv</code> within a
    scrollarea.</li>
  </ul>

  <p>With the exception of ttk::label, ttk::entry, and ttk::separator, all
  these widgets have bult-in mouse wheel event bindings.</p>

  <blockquote>
    <img src="ScrollableFrmDemo2.png" alt="ScrollableFrmDemo2" width="605"
    height="516">
  </blockquote>

  <p>Here is the relevant code:</p>

  <blockquote>
    <pre>
package require Tk 8.5.9                        ;<span class=
"cmt"># for ttk::spinbox</span>
package require mentry_tile 3.2                 ;<span class=
"cmt"># for mouse wheel support</span>
package require tablelist_tile 6.5              ;<span class=
"cmt"># for -(x|y)mousewheelwindow</span>
                                                ;<span class=
 "cmt"># and scrollutil::scrollarea</span>
<span class="red">package require scrollutil_tile</span>
source styleUtil.tcl

wm title . "Scrollutil Demo"

<span class="cmt">#
# Create a scrollableframe within a scrollarea
#</span>
set tf [ttk::frame .tf]
<span class="red">set sa [scrollutil::scrollarea $tf.sa]
set sf [scrollutil::scrollableframe $sa.sf]
$sa setwidget $sf</span>

<span class="cmt">#
# Get the content frame and populate it
#</span>
<span class="red">set cf [$sf contentframe]</span>
source SuScrollableFrmContent.tcl

<span class="cmt">#
# Make the keyboard navigation more user-friendly
#</span>
foreach w [list $cb $sb $e $me] {
    bind $w &lt;&lt;TraverseIn&gt;&gt; [list <span class="red">$sf see %W</span>]
}
foreach w [list $txt $lb $tbl $tv] {
    bind $w &lt;&lt;TraverseIn&gt;&gt; [list seeScrollarea $sf %W]
}
proc seeScrollarea {sf w} { <span class="red">$sf see [scrollutil::getscrollarea $w]</span> }
</pre>
  </blockquote>

  <p>Whenever the <code>&lt;&lt;TraverseIn&gt;&gt;</code> virtual event is sent
  to one of the four widgets created within scrollareas, we query the path name
  of the corresponding scrollarea via <code><a href=
  "scrollarea.html#getscrollarea">scrollutil::getscrollarea</a></code> and
  bring that scrollarea (including the scrollbars and the border) into view
  rather than just the widget in question.&nbsp; While <i>in this script</i> we
  could have used&nbsp; <code>[winfo parent]</code>&nbsp; instead, the command
  <code>scrollutil::getscrollarea</code> is the recommended one, being that it
  works also for widgets that are no children of the corresponding
  scrollareas.</p>

  <p>Here is the additional stuff related to the mouse wheel events, using the
  Scrollutil commands described in the <a href="#ov_what">What Is
  Scrollutil?</a> section:</p>

  <blockquote>
    <pre>
<span class="cmt">#
# Create mouse wheel event bindings for the binding tag "all" and
# register the scrollableframe for scrolling by these bindings
#</span>
<span class="red">scrollutil::createWheelEventBindings all
scrollutil::enableScrollingByWheel $sf</span>

<span class="cmt">#
# Adapt the handling of the mouse wheel events for the text, listbox,
# ttk::combobox, ttk::spinbox, tablelist, and ttk::treeview widgets, as
# well as for the entry components of the mentry widget of type "Date"
#</span>
set entryList [$me entries]
<span class="red">scrollutil::adaptWheelEventHandling $txt $lb $cb $sb $tbl $tv {*}$entryList</span>

<span class="cmt">#
# For the entry components of the mentry widget
# set the "focus check window" to the mentry
#</span>
<span class="red">scrollutil::setFocusCheckWindow {*}$entryList $me</span>
</pre>
  </blockquote>

  <p>Notice that we have passed, among others, the tablelist widget to the
  <code><a href=
  "wheelEvent.html#adapt">scrollutil::adaptWheelEventHandling</a></code>
  command.&nbsp; This will only work for Tablelist versions 6.4 and later,
  because the command handles tablelist widgets by setting their
  <code>-xmousewheelwindow</code> and <code>-ymousewheelwindow</code> options
  to the path name of the containing toplevel window, and these options were
  introduced in Tablelist version 6.4.&nbsp; (For earlier Tablelist versions
  the command silently ignores any tablelist widget passed to it as
  argument.)</p>

  <p>As already mentioned, in the file <code>SuScrollableFrmContent.tcl</code>
  the scrolled text, listbox, tablelist, and ttk::treeview widgets are created
  within <a href="scrollarea.html">scrollarea</a> widgets:</p>

  <blockquote>
    <pre>
<span class="red">set _sa [scrollutil::scrollarea ...]</span>
set txt [text $_sa.txt -font TkFixedFont -width 73]
<span class="red">scrollutil::addMouseWheelSupport $txt
$_sa setwidget $txt</span>
grid $_sa ...

. . .

<span class="red">set _sa [scrollutil::scrollarea ...]</span>
set lb [listbox $_sa.lb -width 0]
<span class="red">$_sa setwidget $lb</span>
grid $_sa ...

. . .

<span class="red">set _sa [scrollutil::scrollarea ...]</span>
set tbl [tablelist::tablelist $_sa.tbl ...]
. . .
<span class="red">$_sa setwidget $tbl</span>
grid $_sa ...

. . .

<span class="red">set _sa [scrollutil::scrollarea ... -borderwidth 0]</span>
set tv [ttk::treeview $_sa.tv ...]
. . .
<span class="red">$_sa setwidget $tv</span>
grid $_sa ...
</pre>
  </blockquote>

  <p>In the case of the text, listbox, and tablelist widgets we use scrollarea
  widgets with their default&nbsp; <code>-borderwidth 1 -relief
  sunken</code>&nbsp; settings, which will cause the <code><a href=
  "scrollarea.html#setwidget">setwidget</a></code> subcommand of the associated
  Tcl commands to set the <code>-borderwidth</code> option of the text,
  listbox, and tablelist widgets to <code>0</code>.&nbsp; On the other hand,
  for the ttk::treeview we use a scrollarea widget with&nbsp;
  <code>-borderwidth 0</code>,&nbsp; because the ttk::treeview has a border of
  width <code>1</code> and doesn't support the <code>-borderwidth</code>
  configuration option.</p>

  <p>For our text widget we prefer a mouse wheel event handling that scrolls
  the widget by lines rather than pixels, as done by the <code>Text</code>
  class bindings in Tk 8.5 and later; we achieve this by passing the path name
  <code>$txt</code> to the <code><a href=
  "wheelEvent.html#add">scrollutil::addMouseWeelSupport</a></code> command.</p>

  <p>The file <code>SuScrollableFrmContent.tcl</code> contains also the
  implementation of the procedure <code>configTablelist</code>, associated with
  the "Configure Tablelist Widget" button as the value of its
  <code>-command</code> option.&nbsp; This procedure opens a toplevel window
  that contains a <a href=
  "scrollableframe.html">scrollutil::scrollableframe</a> widget created
  with the&nbsp; <code><a href=
  "scrollableframe.html#fitcontentwidth">-fitcontentwidth</a> yes</code>&nbsp;
  setting within a <a href="scrollarea.html">scrollarea</a> and invokes the
  <code><a href=
  "wheelEvent.html#enable">scrollutil::enableScrollingByWheel</a></code>
  command for this scrollableframe, thus registering the latter for scrolling
  by the already created mouse wheel event bindings for the binding tag
  <code>"all"</code>.&nbsp; After that it populates the content frame of the
  scrollableframe with ttk::label, ttk::combobox, ttk::spinbox, ttk::entry, and
  ttk::checkbutton widgets used to display and edit the configuration options
  of the tablelist widget.&nbsp; The procedure handles the
  <code>&lt;&lt;TraverseIn&gt;&gt;</code> virtual event sent to one of these
  widgets with the aid of the scrollableframe's <code><a href=
  "scrollableframe.html#see">see</a></code> subcommand.&nbsp; Whenever a
  ttk::combobox or ttk::spinbox is created, the <code><a href=
  "wheelEvent.html#adapt">scrollutil::adaptWheelEventHandling</a></code>
  command is invoked for it, being that these widgets have built-in bindings
  for the mouse wheel events.</p>

  <p>The widgets populating the content frame are managed using
  <code>grid</code>.&nbsp; In case of the ttk::entry widgets we invoke
  <code>grid</code> with&nbsp; <code>-sticky we</code>.&nbsp; Due to this and
  the&nbsp; <code>-fitcontentwidth yes</code>&nbsp; scrollableframe setting,
  the ttk::entry widgets will stretch or shrink whenever the width of the
  scrollableframe changes as a result of resizing the toplevel window.</p>

  <blockquote>
    <img src="TablelistConfig.png" alt="TablelistConfig" width="382"
    height="403">
  </blockquote>

  <h3 id="ex_BwScrollableFrameDemo2">A Script Using Two BWidget ScrollableFrame
  Widgets</h3>

  <p>The script <code>BwScrollableFrmDemo2.tcl</code> in the <code>demos</code>
  directory creates a BWidget ScrollableFrame embedded into a <a href=
  "scrollarea.html">scrollarea</a> widget and then <code>source</code>s the
  script <code>BwScrollableFrmContent.tcl</code>, which populates the content
  frame of the ScrollableFrame with the same widgets as
  <code>SuScrollableFrmContent.tcl</code> in the <a href=
  "#ex_SuScrollableFrameDemo2">previous example</a>.</p>

  <p>Here is the relevant code:</p>

  <blockquote>
    <pre>
package require Tk 8.5.9                        ;<span class=
"cmt"># for ttk::spinbox</span>
package require BWidget
Widget::theme yes
package require mentry_tile 3.2                 ;<span class=
"cmt"># for mouse wheel support</span>
package require tablelist_tile 6.5              ;<span class=
"cmt"># for -(x|y)mousewheelwindow</span>
                                                ;<span class=
 "cmt"># and scrollutil::scrollarea</span>
<span class="red">package require scrollutil_tile</span>
source styleUtil.tcl

wm title . "Scrollutil Demo"

<span class="cmt">#
# Create a ScrollableFrame within a scrollarea
#</span>
set tf [ttk::frame .tf]
<span class="red">set sa [scrollutil::scrollarea $tf.sa]</span>
set sf [ScrollableFrame $sa.sf]
<span class="red">$sa setwidget $sf</span>

. . .

<span class="cmt">#
# Get the content frame and populate it
#</span>
set cf [$sf getframe]
source BwScrollableFrmContent.tcl

<span class="cmt">#
# Make the keyboard navigation more user-friendly
#</span>
foreach w [list $cb $sb $e $me] {
    bind $w &lt;&lt;TraverseIn&gt;&gt; [list $sf see %W]
}
foreach w [list $txt $lb $tbl $tv] {
    bind $w &lt;&lt;TraverseIn&gt;&gt; [list seeScrollarea $sf %W]
}
proc seeScrollarea {sf w} { $sf see [<span class="red">scrollutil::getscrollarea $w</span>] }
</pre>
  </blockquote>

  <p>The additional stuff related to the mouse wheel events contains exactly
  the same Scrollutil command invocations as the one in the previous
  example.</p>

  <p>The file <code>BwScrollableFrmContent.tcl</code> contains also the
  implementation of the procedure <code>configTablelist</code>, associated with
  the "Configure Tablelist Widget" button as the value of its
  <code>-command</code> option.&nbsp; This procedure opens a toplevel window
  that contains a BWidget ScrollableFrame created with the&nbsp;
  <code>-constrainedwidth yes</code>&nbsp; setting within a <a href=
  "scrollarea.html">scrollarea</a> widget and invokes the <code><a href=
  "wheelEvent.html#enable">scrollutil::enableScrollingByWheel</a></code>
  command for this ScrollableFrame, thus registering the latter for scrolling
  by the already created mouse wheel event bindings for the binding tag
  <code>"all"</code>.&nbsp; After that it populates the content frame of the
  ScrollableFrame with ttk::label, ttk::combobox, ttk::spinbox, ttk::entry, and
  ttk::checkbutton widgets used to display and edit the configuration options
  of the tablelist widget.&nbsp; The procedure handles the
  <code>&lt;&lt;TraverseIn&gt;&gt;</code> virtual event sent to one of these
  widgets with the aid of the ScrollableFrame's <code>see</code>
  subcommand.&nbsp; Whenever a ttk::combobox or ttk::spinbox is created, the
  <code><a href=
  "wheelEvent.html#adapt">scrollutil::adaptWheelEventHandling</a></code>
  command is invoked for it, being that these widgets have built-in bindings
  for the mouse wheel events.</p>

  <p>Again, all this is nearly identical to what we did in the previous
  example.</p>

  <h3 id="ex_ScrolledFrameDemo2">A Script Using Two iwidgets::scrolledframe
  Widgets</h3>

  <p>The script <code>ScrolledFrmDemo2.tcl</code> in the <code>demos</code>
  directory creates an iwidgets::scrolledframe widget and then
  <code>source</code>s the file <code>ScrolledFrmContent.tcl</code>, which
  populates the content frame of the scrolledframe with the same widgets as
  <code>SuScrollableFrmContent.tcl</code> and
  <code>BwScrollableFrmContent.tcl</code> in the two previous examples.</p>

  <p>Here is the relevant code:</p>

  <blockquote>
    <pre>
package require Tk 8.5.9                        ;<span class=
"cmt"># for ttk::spinbox</span>
if {[catch {package require iwidgets} result1] != 0 &&
    [catch {package require Iwidgets} result2] != 0} {
    error "$result1; $result2"
}
source scrolledwidgetPatch.itk                  ;<span class=
"cmt"># adds ttk::scrollbar widgets</span>
package require mentry_tile 3.2                 ;<span class=
"cmt"># for mouse wheel support</span>
package require tablelist_tile 6.5              ;<span class=
"cmt"># for -(x|y)mousewheelwindow</span>
                                                ;<span class=
"cmt"># and scrollutil::scrollarea</span>
<span class="red">package require scrollutil_tile</span>
source styleUtil.tcl

wm title . "Scrollutil Demo"

. . .

<span class="cmt">#
# Create a scrolledframe
#</span>
set tf [ttk::frame .tf]
set sf [iwidgets::scrolledframe $tf.sf -borderwidth 1 -relief sunken \
        -scrollmargin 0]
. . .

<span class="cmt">#
# Get the content frame and populate it
#</span>
set cf [$sf childsite]
. . .
source ScrolledFrmContent.tcl
</pre>
  </blockquote>

  <p>The additional stuff related to the mouse wheel events contains exactly
  the same Scrollutil command invocations as the one in the two previous
  examples.</p>

  <p>The file <code>ScrolledFrmContent.tcl</code> contains also the
  implementation of the procedure <code>configTablelist</code>, associated with
  the "Configure Tablelist Widget" button as the value of its
  <code>-command</code> option.&nbsp; This procedure opens a toplevel window
  that contains an iwidgets::scrolledframe widget with a manually implemented
  equivalent of the&nbsp; <code><a href=
  "scrollableframe.html#fitcontentwidth">-fitcontentwidth</a> yes</code>&nbsp;
  <a href="scrollableframe.html">scrollutil::scrollableframe</a> and&nbsp;
  <code>-constrainedwidth yes</code>&nbsp; BWidget ScrollableFrame settings and
  invokes the <code><a href=
  "wheelEvent.html#enable">scrollutil::enableScrollingByWheel</a></code>
  command for this scrolledframe, thus registering the latter for scrolling by
  the already created mouse wheel event bindings for the binding tag
  <code>"all"</code>.&nbsp; After that it populates the content frame of the
  scrolledframe with ttk::label, ttk::combobox, ttk::spinbox, ttk::entry, and
  ttk::checkbutton widgets used to display and edit the configuration options
  of the tablelist widget.&nbsp; Whenever a ttk::combobox or ttk::spinbox is
  created, the <code><a href=
  "wheelEvent.html#adapt">scrollutil::adaptWheelEventHandling</a></code>
  command is invoked for it, being that these widgets have built-in bindings
  for the mouse wheel events.</p>

  <p>Again, all this is nearly identical to what we did in the two previous
  examples.</p>

  <div align="center">
    <p><a href="#contents">Contents</a>&nbsp;&nbsp;&nbsp;&nbsp; <a href=
    "index.html">Start page</a></p>
  </div>
</body>
</html>
