package provide DS9 1.0

######
# Begin autogenerated taccle (version 1.3) routines.
# Although taccle itself is protected by the GNU Public License (GPL)
# all user-supplied functions are protected by their respective
# author's license.  See http://mini.net/tcl/taccle for other details.
######

namespace eval mode {
    variable yylval {}
    variable table
    variable rules
    variable token {}
    variable yycnt 0
    variable yyerr 0
    variable save_state 0

    namespace export yylex
}

proc mode::YYABORT {} {
    return -code return 1
}

proc mode::YYACCEPT {} {
    return -code return 0
}

proc mode::YYERROR {} {
    variable yyerr
    set yyerr 1
}

proc mode::yyclearin {} {
    variable token
    variable yycnt
    set token {}
    incr yycnt -1
}

proc mode::yyerror {s} {
    puts stderr $s
}

proc mode::setupvalues {stack pointer numsyms} {
    upvar 1 1 y
    set y {}
    for {set i 1} {$i <= $numsyms} {incr i} {
        upvar 1 $i y
        set y [lindex $stack $pointer]
        incr pointer
    }
}

proc mode::unsetupvalues {numsyms} {
    for {set i 1} {$i <= $numsyms} {incr i} {
        upvar 1 $i y
        unset y
    }
}

array set mode::table {
  17:257 reduce
  16:273,target 18
  0:258 shift
  5:0,target 8
  0:260 shift
  0:259 shift
  2:257 reduce
  15:0,target 0
  9:0 reduce
  8:257,target 11
  0:261 shift
  0:266,target 9
  11:0 reduce
  4:257 reduce
  0:262 shift
  0:263 shift
  6:257 reduce
  0:264 shift
  3:257,target 6
  0:265 shift
  15:0 accept
  8:257 reduce
  0:266 shift
  0:267 shift
  0:265,target 8
  0:268 shift
  6:0,target 9
  0:275,target 17
  0:269 shift
  0:270 shift
  19:0 reduce
  16:0,target 1
  10:257,target 13
  0:271 shift
  2:0 reduce
  0:272 goto
  0:274 goto
  6:0 reduce
  0:275 goto
  6:257,target 9
  0:264,target 7
  0:274,target 16
  18:257,target 19
  7:0,target 10
  1:257,target 5
  17:0,target 4
  12:0 reduce
  10:0,target 13
  13:257,target 16
  0:263,target 6
  16:0 reduce
  10:257 reduce
  12:257 reduce
  9:257,target 12
  14:257 reduce
  8:0,target 11
  3:0 reduce
  1:0,target 5
  16:257 reduce
  11:0,target 14
  4:257,target 7
  0:262,target 5
  0:272,target 15
  18:257 shift
  7:0 reduce
  1:257 reduce
  16:257,target 2
  3:257 reduce
  11:257,target 14
  5:257 reduce
  13:0 reduce
  9:0,target 12
  0:261,target 4
  19:0,target 3
  7:257 reduce
  0:271,target 14
  2:0,target 18
  12:0,target 15
  9:257 reduce
  17:0 reduce
  7:257,target 10
  16:273 goto
  0:260,target 3
  0:259,target 2
  2:257,target 18
  0:269,target 12
  0:270,target 13
  4:0 reduce
  14:257,target 17
  3:0,target 6
  13:0,target 16
  8:0 reduce
  10:0 reduce
  0:258,target 1
  0:268,target 11
  14:0 reduce
  5:257,target 8
  4:0,target 7
  14:0,target 17
  11:257 reduce
  17:257,target 4
  1:0 reduce
  13:257 reduce
  0:267,target 10
  12:257,target 15
  5:0 reduce
}

array set mode::rules {
  9,l 275
  11,l 275
  15,l 275
  2,l 273
  6,l 275
  12,l 275
  16,l 275
  3,l 272
  7,l 275
  13,l 275
  0,l 276
  17,l 275
  4,l 274
  8,l 275
  10,l 275
  14,l 275
  18,l 275
  1,l 272
  5,l 275
}

array set mode::rules {
  5,dc 1
  0,dc 1
  17,dc 1
  12,dc 1
  8,dc 1
  3,dc 3
  15,dc 1
  10,dc 1
  6,dc 1
  18,dc 1
  1,dc 1
  13,dc 1
  9,dc 1
  4,dc 1
  16,dc 1
  11,dc 1
  7,dc 1
  2,dc 0
  14,dc 1
}

array set mode::rules {
  13,line 44
  2,e 1
  7,line 38
  10,line 41
  4,line 33
  18,line 50
  1,line 29
  15,line 46
  9,line 40
  12,line 43
  6,line 37
  3,line 30
  17,line 49
  14,line 45
  8,line 39
  11,line 42
  5,line 36
  2,line 29
  16,line 47
}

array set mode::lr1_table {
  13,trans {}
  17 {{4 {0 257} 1}}
  0 {{0 0 0} {1 0 0} {3 0 0} {4 {0 257} 0} {5 {0 257} 0} {6 {0 257} 0} {7 {0 257} 0} {8 {0 257} 0} {9 {0 257} 0} {10 {0 257} 0} {11 {0 257} 0} {12 {0 257} 0} {13 {0 257} 0} {14 {0 257} 0} {15 {0 257} 0} {16 {0 257} 0} {17 {0 257} 0} {18 {0 257} 0}}
  18 {{3 0 2}}
  14,trans {}
  1 {{5 {0 257} 1}}
  19 {{3 0 3}}
  15,trans {}
  2 {{18 {0 257} 1}}
  16,trans {{273 18}}
  3 {{6 {0 257} 1}}
  17,trans {}
  0,trans {{258 1} {259 2} {260 3} {261 4} {262 5} {263 6} {264 7} {265 8} {266 9} {267 10} {268 11} {269 12} {270 13} {271 14} {272 15} {274 16} {275 17}}
  4 {{7 {0 257} 1}}
  18,trans {{257 19}}
  1,trans {}
  5 {{8 {0 257} 1}}
  19,trans {}
  2,trans {}
  6 {{9 {0 257} 1}}
  3,trans {}
  7 {{10 {0 257} 1}}
  4,trans {}
  8 {{11 {0 257} 1}}
  5,trans {}
  9 {{12 {0 257} 1}}
  10 {{13 {0 257} 1}}
  6,trans {}
  11 {{14 {0 257} 1}}
  7,trans {}
  12 {{15 {0 257} 1}}
  8,trans {}
  13 {{16 {0 257} 1}}
  10,trans {}
  9,trans {}
  14 {{17 {0 257} 1}}
  11,trans {}
  15 {{0 0 1}}
  12,trans {}
  16 {{1 0 1} {3 0 1} {2 257 0}}
}

array set mode::token_id_table {
  264,line 17
  270,t 0
  269,t 0
  276,line 51
  265,title ROTATE
  274,t 1
  261,line 14
  257,t 0
  270,title 3D
  269,title EXAMINE
  273,line 29
  257,line 7
  262,t 0
  274,title {}
  270,line 23
  269,line 22
  259,title POINTER
  260,title REGION
  266,t 0
  error error
  271,t 0
  264,title ZOOM
  266,line 19
  275,t 1
  error,line 27
  268,title FOOTPRINT
  258,t 0
  263,line 16
  error,title {}
  275,line 35
  273,title {}
  263,t 0
  259,line 12
  260,line 13
  258,title NONE
  272,line 28
  267,t 0
  263,title PAN
  272,t 1
  268,line 21
  267,title CATALOG
  257 STRING_
  276,t 1
  258 NONE_
  259,t 0
  259 POINTER_
  260 REGION_
  260,t 0
  272,title {}
  261 CROSSHAIR_
  265,line 18
  262 COLORBAR_
  263 PAN_
  257,title string
  264 ZOOM_
  264,t 0
  276,title {}
  265 ROTATE_
  262,line 15
  266 CROP_
  267 CATALOG_
  0,t 0
  0 {$}
  262,title COLORBAR
  268 FOOTPRINT_
  268,t 0
  274,line 32
  270 3D_
  269 EXAMINE_
  error,t 0
  271 ILLUSTRATE_
  272 command
  258,line 11
  273,t 1
  273 @PSEUDO1
  266,title CROP
  274 mode
  275 item
  271,line 24
  276 start'
  271,title ILLUSTRATE
  261,t 0
  267,line 20
  275,title {}
  265,t 0
  261,title CROSSHAIR
}

proc mode::yyparse {} {
    variable yylval
    variable table
    variable rules
    variable token
    variable yycnt
    variable lr1_table
    variable token_id_table
    variable yyerr
    variable save_state

    set yycnt 0
    set state_stack {0}
    set value_stack {{}}
    set token ""
    set accepted 0
    set yyerr 0
    set save_state 0

    while {$accepted == 0} {
        set state [lindex $state_stack end]
        if {$token == ""} {
            set yylval ""
            set token [yylex]
            set buflval $yylval
	    if {$token>0} {
	        incr yycnt
            }
        }
        if {![info exists table($state:$token)] || $yyerr} {
	    if {!$yyerr} {
	        set save_state $state
	    }
            # pop off states until error token accepted
            while {[llength $state_stack] > 0 && \
                       ![info exists table($state:error)]} {
                set state_stack [lrange $state_stack 0 end-1]
                set value_stack [lrange $value_stack 0 \
                                       [expr {[llength $state_stack] - 1}]]
                set state [lindex $state_stack end]
            }
            if {[llength $state_stack] == 0} {
 
	        set rr { }
                if {[info exists lr1_table($save_state,trans)] && [llength $lr1_table($save_state,trans)] >= 1} {
                    foreach trans $lr1_table($save_state,trans) {
                        foreach {tok_id nextstate} $trans {
			    set ss $token_id_table($tok_id,title)
			    if {$ss != {}} {
			        append rr "$ss, "
                            }
                        }
                    }
                }
		set rr [string trimleft $rr { }]
		set rr [string trimright $rr {, }]
                yyerror "parse error, expecting: $rr"


                return 1
            }
            lappend state_stack [set state $table($state:error,target)]
            lappend value_stack {}
            # consume tokens until it finds an acceptable one
            while {![info exists table($state:$token)]} {
                if {$token == 0} {
                    yyerror "end of file while recovering from error"
                    return 1
                }
                set yylval {}
                set token [yylex]
                set buflval $yylval
            }
            continue
        }
        switch -- $table($state:$token) {
            shift {
                lappend state_stack $table($state:$token,target)
                lappend value_stack $buflval
                set token ""
            }
            reduce {
                set rule $table($state:$token,target)
                set ll $rules($rule,l)
                if {[info exists rules($rule,e)]} {
                    set dc $rules($rule,e)
                } else {
                    set dc $rules($rule,dc)
                }
                set stackpointer [expr {[llength $state_stack]-$dc}]
                setupvalues $value_stack $stackpointer $dc
                set _ $1
                set yylval [lindex $value_stack end]
                switch -- $rule {
                    2 { global ds9; if {!$ds9(init)} {YYERROR} else {yyclearin; YYACCEPT} }
                    4 { ProcessCmdSet current mode $1 ChangeMode }
                    5 { set _ none }
                    6 { set _ region }
                    7 { set _ crosshair }
                    8 { set _ colorbar }
                    9 { set _ pan }
                    10 { set _ zoom }
                    11 { set _ rotate }
                    12 { set _ crop }
                    13 { set _ catalog }
                    14 { set _ footprint }
                    15 { set _ examine }
                    16 { set _ 3d }
                    17 { set _ illustrate }
                    18 { set _ region }
                }
                unsetupvalues $dc
                # pop off tokens from the stack if normal rule
                if {![info exists rules($rule,e)]} {
                    incr stackpointer -1
                    set state_stack [lrange $state_stack 0 $stackpointer]
                    set value_stack [lrange $value_stack 0 $stackpointer]
                }
                # now do the goto transition
                lappend state_stack $table([lindex $state_stack end]:$ll,target)
                lappend value_stack $_
            }
            accept {
                set accepted 1
            }
            goto -
            default {
                puts stderr "Internal parser error: illegal command $table($state:$token)"
                return 2
            }
        }
    }
    return 0
}

######
# end autogenerated taccle functions
######

proc mode::yyerror {msg} {
     variable yycnt
     variable yy_current_buffer
     variable index_

     ParserError $msg $yycnt $yy_current_buffer $index_
}
