.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "funimage 1"
.TH funimage 1 "April 14, 2011" "version 1.4.5" "SAORD Documentation"
.SH "NAME"
funimage \- create a FITS image from a Funtools data file
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
\&\fBfunimage\fR [\-a] <iname> <oname> [bitpix=n]
\&\fBfunimage\fR [\-l] <iname> <oname> <xcol:xdims> <ycol:ydims> <vcol> [bitpix=n]
\&\fBfunimage\fR [\-p x|y] <iname> <oname> [bitpix=n]
.SH "OPTIONS"
.IX Header "OPTIONS"
.Vb 3
\&  \-a       # append to existing output file as an image extension
\&  \-l       # input is a list file containing xcol, ycol, value
\&  \-p [x|y] # project along x or y axis to create a 1D image
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\fBfunimage\fR creates a primary \s-1FITS\s0 image from the specified
\&\s-1FITS\s0 Extension
and/or
Image Section
of a \s-1FITS\s0 file, or from an
Image Section
of a non-FITS array, or from a raw event file.
.PP
The first argument to the program specifies the \s-1FITS\s0 input image,
array, or raw event file to process.  If \*(L"stdin\*(R" is specified, data are
read from the standard input. Use Funtools
Bracket Notation to specify \s-1FITS\s0 extensions, image sections, and
filters.  The second argument is the output \s-1FITS\s0 file.  If \*(L"stdout\*(R" is
specified, the \s-1FITS\s0 image is written to the standard output.  By
default, the output pixel values are of the same data type as those of the
input file (or type \*(L"int\*(R" when binning a table), but this can be
overridden using an optional third argument of the form:
.PP
.Vb 1
\&  bitpix=n
.Ve
.PP
where n is 8,16,32,\-32,\-64, for unsigned char, short, int, float and double,
respectively.
.PP
If the input data are of type image, the appropriate section is
extracted and blocked (based on how the 
Image Section is specified), and
the result is written to the \s-1FITS\s0 primary image.  When an integer
image containing the \s-1BSCALE\s0 and \s-1BZERO\s0 keywords is converted to float,
the pixel values are scaled and the scaling keywords are deleted from the
output header. When converting integer scaled data to integer
(possibly of a different size), the pixels are not scaled and the
scaling keywords are retained.
.PP
If the input data is a binary table or raw event file, these are
binned into an image, from which a section is extracted and blocked,
and written to a primary \s-1FITS\s0 image.  In this case, it is necessary to
specify the two columns that will be used in the 2D binning.  This can
be done on the command line using the \fBbincols=(x,y)\fR keyword:
.PP
.Vb 1
\&  funcnts "foo.ev[EVENTS,bincols=(detx,dety)]"
.Ve
.PP
The full form of the \fBbincols=\fR specifier is:
.PP
.Vb 1
\&  bincols=([xname[:tlmin[:tlmax:[binsiz]]]],[yname[:tlmin[:tlmax[:binsiz]]]])
.Ve
.PP
where the tlmin, tlmax, and binsiz specifiers determine the image binning
dimensions:
.PP
.Vb 2
\&  dim = (tlmax - tlmin)/binsiz     (floating point data)
\&  dim = (tlmax - tlmin)/binsiz + 1 (integer data)
.Ve
.PP
Using this syntax, it is possible to bin any two columns of a binary
table at any bin size.  Note that the tlmin, tlmax, and binsiz
specifiers can be omitted if \s-1TLMIN\s0, \s-1TLMAX\s0, and \s-1TDBIN\s0 header parameters
(respectively) are present in the \s-1FITS\s0 binary table header for the
column in question. Note also that if only one parameter is specified,
it is assumed to be tlmax, and tlmin defaults to 1. If two parameters
are specified, they are assumed to be tlmin and tlmax.
See Binning \s-1FITS\s0 Binary Tables and Non-FITS
Event Files for more information about binning parameters.
.PP
By default, a new 2D \s-1FITS\s0 image file is created and the image is written
to the primary \s-1HDU\s0.  If the \fB\-a\fR (append) switch is specified,
the image is appended to an existing \s-1FITS\s0 file as an \s-1IMAGE\s0 extension.
(If the output file does not exist, the switch is effectively ignored
and the image is written to the primary \s-1HDU\s0.)  This can be useful in a
shell programming environment when processing multiple \s-1FITS\s0 images
that you want to combine into a single final \s-1FITS\s0 file.
.PP
\&\fBfunimage\fR also can take input from a table containing columns of
x, y, and value (e.g., the output from \fBfundisp \-l\fR which
displays each image x and y and the number of counts at that
position.) When the \fB\-l\fR (list) switch is used, the input file is
taken to be a \s-1FITS\s0 or \s-1ASCII\s0 table containing (at least) three columns
that specify the x and y image coordinates and the value of that
image pixel. In this case, \fBfunimage\fR requires four extra
arguments: xcolumn:xdims, ycolumn:ydims, vcolumn and bitpix=n. The x
and y col:dim information takes the form: 
.PP
.Vb 3
\&  name:dim               # values range from 1 to dim
\&  name:min:max           # values range from min to max
\&  name:min:max:binsiz    # dimensions scaled by binsize
.Ve
.PP
In particular, the min value should be used whenever the
minimum coordinate value is something other than one. For example:
.PP
.Vb 1
\&  funimage \-l foo.lst foo.fits xcol:0:512 ycol:0:512 value bitpix=-32
.Ve
.PP
The list feature also can be used to read unnamed columns from standard
input: simply replace the column name with a null string. Note
that the dimension information is still required:
.PP
.Vb 5
\&  funimage \-l stdin foo.fits "":0:512 "":0:512 "" bitpix=-32
\&  240 250 1
\&  255 256 2
\&  ...
\&  ^D
.Ve
.PP
The list feature provides a simple way to generate a blank image.
If you pass a Column-based Text File
to funimage in which the text header contains the required image
information, then funimage will correctly make a blank image. For
example, consider the following text file (called foo.txt):
.PP
.Vb 3
\&  x:I:1:10  y:I:1:10
\&  ------    ------
\&  0         0
.Ve
.PP
This text file defines two columns, x and y, each of data type 32-bit int and
image dimension 10. The command:
.PP
.Vb 1
\&  funimage foo.txt foo.fits bitpix=8
.Ve
.PP
will create an empty \s-1FITS\s0 image called foo.fits containing a 10x10
image of unsigned char:
.PP
.Vb 13
\&  fundisp foo.fits
\&           1      2      3      4      5      6      7      8      9     10
\&      ------ ------ ------ ------ ------ ------ ------ ------ ------ ------
\&  10:      0      0      0      0      0      0      0      0      0      0
\&   9:      0      0      0      0      0      0      0      0      0      0
\&   8:      0      0      0      0      0      0      0      0      0      0
\&   7:      0      0      0      0      0      0      0      0      0      0
\&   6:      0      0      0      0      0      0      0      0      0      0
\&   5:      0      0      0      0      0      0      0      0      0      0
\&   4:      0      0      0      0      0      0      0      0      0      0
\&   3:      0      0      0      0      0      0      0      0      0      0
\&   2:      0      0      0      0      0      0      0      0      0      0
\&   1:      1      0      0      0      0      0      0      0      0      0
.Ve
.PP
Note that the text file must contain at least
one row of data. However, in the present example, event position 0,0 is
outside the limits of the image and will be ignored. (You can, of course,
use real x,y values to seed the image with data.)
.PP
Furthermore, you can use the \s-1TEXT\s0 filter specification to obviate the need for
an input text file altogether. The following command will create the same
10x10 char image without an actual input file:
.PP
.Vb 3
\&  funimage stdin'[TEXT(x:I:10,y:I:10)]' foo.fits bitpix=8 < /dev/null
\&or
\&  funimage /dev/null'[TEXT(x:I:10,y:I:10)]' foo.fits bitpix=8
.Ve
.PP
You also can use either of these methods to generate a region mask simply
by appending a region inside the filter brackets and specfying \fBmask=all\fR
along with the bitpix. For example, the following command will generate a
10x10 char mask using 3 regions:
.PP
.Vb 2
\&  funimage stdin'[TEXT(x:I:10,y:I:10),cir(5,5,4),point(10,1),-cir(5,5,2)]' \e
\&  foo.fits bitpix=8,mask=all < /dev/null
.Ve
.PP
The resulting mask looks like this:
.PP
.Vb 13
\&  fundisp foo.fits
\&           1      2      3      4      5      6      7      8      9     10
\&      ------ ------ ------ ------ ------ ------ ------ ------ ------ ------
\&  10:      0      0      0      0      0      0      0      0      0      0
\&   9:      0      0      0      0      0      0      0      0      0      0
\&   8:      0      0      1      1      1      1      1      0      0      0
\&   7:      0      1      1      1      1      1      1      1      0      0
\&   6:      0      1      1      0      0      0      1      1      0      0
\&   5:      0      1      1      0      0      0      1      1      0      0
\&   4:      0      1      1      0      0      0      1      1      0      0
\&   3:      0      1      1      1      1      1      1      1      0      0
\&   2:      0      0      1      1      1      1      1      0      0      0
\&   1:      0      0      0      0      0      0      0      0      0      2
.Ve
.PP
You can use \fBfunimage\fR to create 1D image projections along the x
or y axis using the \fB\-p [x|y]\fR switch. This capability works for
both images and tables. For example consider a \s-1FITS\s0 table named ev.fits
containing the following rows:
.PP
.Vb 17
\&         X        Y
\&  -------- --------
\&         1        1
\&         1        2
\&         1        3
\&         1        4
\&         1        5
\&         2        2
\&         2        3
\&         2        4
\&         2        5
\&         3        3
\&         3        4
\&         3        5
\&         4        4
\&         4        5
\&         5        5
.Ve
.PP
A corresponding 5x5 image, called dim2.fits, would therefore contain:
.PP
.Vb 7
\&              1          2          3          4          5
\&     ---------- ---------- ---------- ---------- ----------
\&  5:          1          1          1          1          1
\&  4:          1          1          1          1          0
\&  3:          1          1          1          0          0
\&  2:          1          1          0          0          0
\&  1:          1          0          0          0          0
.Ve
.PP
A projection along the y axis can be performed on either the table or
the image:
.PP
.Vb 4
\&  funimage \-p y ev.fits stdout | fundisp stdin
\&              1          2          3          4          5
\&     ---------- ---------- ---------- ---------- ----------
\&  1:          1          2          3          4          5
.Ve
.PP
.Vb 4
\&  funimage \-p y dim2.fits stdout | fundisp stdin
\&              1          2          3          4          5
\&     ---------- ---------- ---------- ---------- ----------
\&  1:          1          2          3          4          5
.Ve
.PP
Furthermore, you can create a 1D image projection along any column of
a table by using the \fBbincols=[column]\fR filter specification and
specifying a single column. For example, the following command
projects the same 1D image along the y axis of a table as use of
the \fB\-p y\fR switch:
.PP
.Vb 4
\&  funimage ev.fits'[bincols=y]' stdout | fundisp stdin 
\&              1          2          3          4          5
\&     ---------- ---------- ---------- ---------- ----------
\&  1:          1          2          3          4          5
.Ve
.PP
Examples:
.PP
Create a \s-1FITS\s0 image from a \s-1FITS\s0 binary table:
.PP
.Vb 1
\&  [sh] funimage test.ev test.fits
.Ve
.PP
Display the \s-1FITS\s0 image generated from a blocked section of \s-1FITS\s0 binary table:
.PP
.Vb 5
\&  [sh]  funimage "test.ev[2:8,3:7,2]" stdout | fundisp stdin
\&                    1         2         3
\&            --------- --------- ---------
\&         1:        20        28        36
\&         2:        28        36        44
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
See funtools(7) for a list of Funtools help pages
