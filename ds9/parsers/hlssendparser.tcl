package provide DS9 1.0

######
# Begin autogenerated taccle (version 1.3) routines.
# Although taccle itself is protected by the GNU Public License (GPL)
# all user-supplied functions are protected by their respective
# author's license.  See http://mini.net/tcl/taccle for other details.
######

namespace eval hlssend {
    variable yylval {}
    variable table
    variable rules
    variable token {}
    variable yycnt 0
    variable yyerr 0
    variable save_state 0

    namespace export yylex
}

proc hlssend::YYABORT {} {
    return -code return 1
}

proc hlssend::YYACCEPT {} {
    return -code return 0
}

proc hlssend::YYERROR {} {
    variable yyerr
    set yyerr 1
}

proc hlssend::yyclearin {} {
    variable token
    variable yycnt
    set token {}
    incr yycnt -1
}

proc hlssend::yyerror {s} {
    puts stderr $s
}

proc hlssend::setupvalues {stack pointer numsyms} {
    upvar 1 1 y
    set y {}
    for {set i 1} {$i <= $numsyms} {incr i} {
        upvar 1 $i y
        set y [lindex $stack $pointer]
        incr pointer
    }
}

proc hlssend::unsetupvalues {numsyms} {
    for {set i 1} {$i <= $numsyms} {incr i} {
        upvar 1 $i y
        unset y
    }
}

array set hlssend::table {
  0:260 shift
  2:257 shift
  5:0,target 0
  15:0,target 5
  9:0 reduce
  2:258 shift
  11:0 reduce
  2:274,target 15
  2:259 shift
  2:261 shift
  2:262 shift
  0:265 shift
  15:0 reduce
  4:263 shift
  0:265,target 2
  4:264 shift
  6:0,target 9
  0:275,target 5
  2:267 shift
  20:0 reduce
  19:0 reduce
  16:0,target 2
  0:271 shift
  2:268 shift
  4:266 shift
  2:269 shift
  2:270 shift
  0:273 shift
  0:275 goto
  6:0 reduce
  2:274 shift
  2:262,target 10
  2:276 goto
  7:0,target 8
  17:0,target 15
  12:0 reduce
  10:0,target 6
  4:277 goto
  2:261,target 9
  16:0 reduce
  0:273,target 4
  8:0,target 13
  3:0 reduce
  18:0,target 16
  1:0,target 1
  11:0,target 10
  2:259,target 8
  2:269,target 13
  2:270,target 14
  7:0 reduce
  4:277,target 20
  13:0 reduce
  9:0,target 12
  2:258,target 7
  20:0,target 4
  19:0,target 17
  0:271,target 3
  2:268,target 12
  4:266,target 19
  12:0,target 11
  17:0 reduce
  0:260,target 1
  2:257,target 6
  2:267,target 11
  3:0,target 3
  13:0,target 7
  8:0 reduce
  10:0 reduce
  4:264,target 18
  2:276,target 16
  14:0 reduce
  14:0,target 14
  18:0 reduce
  1:0 reduce
  4:263,target 17
  5:0 accept
}

array set hlssend::rules {
  9,l 276
  11,l 276
  15,l 277
  2,l 275
  6,l 276
  12,l 276
  16,l 277
  3,l 275
  7,l 276
  13,l 276
  0,l 278
  17,l 277
  4,l 275
  8,l 276
  10,l 276
  14,l 276
  1,l 275
  5,l 276
}

array set hlssend::rules {
  5,dc 1
  0,dc 1
  17,dc 1
  12,dc 1
  8,dc 1
  3,dc 1
  15,dc 1
  10,dc 1
  6,dc 1
  1,dc 1
  13,dc 1
  9,dc 1
  4,dc 2
  16,dc 1
  11,dc 1
  7,dc 1
  2,dc 2
  14,dc 1
}

array set hlssend::rules {
  13,line 44
  7,line 38
  10,line 41
  4,line 33
  1,line 30
  15,line 48
  9,line 40
  12,line 43
  6,line 37
  3,line 32
  17,line 50
  14,line 45
  8,line 39
  11,line 42
  5,line 36
  2,line 31
  16,line 49
}

array set hlssend::lr1_table {
  13,trans {}
  17 {{15 0 1}}
  0 {{0 0 0} {1 0 0} {2 0 0} {3 0 0} {4 0 0}}
  14,trans {}
  18 {{16 0 1}}
  1 {{1 0 1}}
  15,trans {}
  20 {{4 0 2}}
  19 {{17 0 1}}
  2 {{2 0 1} {5 0 0} {6 0 0} {7 0 0} {8 0 0} {9 0 0} {10 0 0} {11 0 0} {12 0 0} {13 0 0} {14 0 0}}
  16,trans {}
  3 {{3 0 1}}
  17,trans {}
  4 {{4 0 1} {15 0 0} {16 0 0} {17 0 0}}
  0,trans {{260 1} {265 2} {271 3} {273 4} {275 5}}
  18,trans {}
  5 {{0 0 1}}
  1,trans {}
  20,trans {}
  19,trans {}
  2,trans {{257 6} {258 7} {259 8} {261 9} {262 10} {267 11} {268 12} {269 13} {270 14} {274 15} {276 16}}
  6 {{9 0 1}}
  3,trans {}
  7 {{8 0 1}}
  4,trans {{263 17} {264 18} {266 19} {277 20}}
  8 {{13 0 1}}
  5,trans {}
  10 {{6 0 1}}
  9 {{12 0 1}}
  6,trans {}
  11 {{10 0 1}}
  7,trans {}
  12 {{11 0 1}}
  8,trans {}
  13 {{7 0 1}}
  10,trans {}
  9,trans {}
  14 {{14 0 1}}
  11,trans {}
  15 {{5 0 1}}
  12,trans {}
  16 {{2 0 2}}
}

array set hlssend::token_id_table {
  264,line 15
  270,t 0
  269,t 0
  276,line 35
  265,title LOCK
  274,t 0
  261,line 12
  257,t 0
  270,title SMOOTH
  269,title SLICE
  273,line 24
  278,t 1
  257,line 8
  262,t 0
  274,title WCS
  270,line 21
  269,line 20
  259,title BLOCK
  260,title CHANNEL
  266,t 0
  278,title {}
  error error
  271,t 0
  264,title LIGHTNESS
  266,line 17
  278,line 51
  275,t 1
  error,line 28
  268,title SCALELIMITS
  258,t 0
  263,line 14
  error,title {}
  275,line 29
  273,title VIEW
  263,t 0
  259,line 10
  260,line 11
  258,title BIN
  277,title {}
  272,line 23
  267,t 0
  263,title HUE
  272,t 0
  268,line 19
  267,title SCALE
  257 AXES_
  276,t 1
  258 BIN_
  259,t 0
  259 BLOCK_
  260 CHANNEL_
  260,t 0
  272,title VALUE
  261 COLORBAR_
  265,line 16
  262 CROP_
  263 HUE_
  277,line 47
  257,title AXES
  264 LIGHTNESS_
  264,t 0
  276,title {}
  265 LOCK_
  262,line 13
  266 SATURATION_
  267 SCALE_
  0,t 0
  0 {$}
  262,title CROP
  268 SCALELIMITS_
  268,t 0
  274,line 25
  270 SMOOTH_
  269 SLICE_
  error,t 0
  271 SYSTEM_
  272 VALUE_
  258,line 9
  273,t 0
  273 VIEW_
  266,title SATURATION
  274 WCS_
  275 hlssend
  271,line 22
  276 lock
  277,t 1
  277 channel
  271,title SYSTEM
  278 start'
  261,t 0
  267,line 18
  275,title {}
  265,t 0
  261,title COLORBAR
}

proc hlssend::yyparse {} {
    variable yylval
    variable table
    variable rules
    variable token
    variable yycnt
    variable lr1_table
    variable token_id_table
    variable yyerr
    variable save_state

    set yycnt 0
    set state_stack {0}
    set value_stack {{}}
    set token ""
    set accepted 0
    set yyerr 0
    set save_state 0

    while {$accepted == 0} {
        set state [lindex $state_stack end]
        if {$token == ""} {
            set yylval ""
            set token [yylex]
            set buflval $yylval
	    if {$token>0} {
	        incr yycnt
            }
        }
        if {![info exists table($state:$token)] || $yyerr} {
	    if {!$yyerr} {
	        set save_state $state
	    }
            # pop off states until error token accepted
            while {[llength $state_stack] > 0 && \
                       ![info exists table($state:error)]} {
                set state_stack [lrange $state_stack 0 end-1]
                set value_stack [lrange $value_stack 0 \
                                       [expr {[llength $state_stack] - 1}]]
                set state [lindex $state_stack end]
            }
            if {[llength $state_stack] == 0} {
 
	        set rr { }
                if {[info exists lr1_table($save_state,trans)] && [llength $lr1_table($save_state,trans)] >= 1} {
                    foreach trans $lr1_table($save_state,trans) {
                        foreach {tok_id nextstate} $trans {
			    set ss $token_id_table($tok_id,title)
			    if {$ss != {}} {
			        append rr "$ss, "
                            }
                        }
                    }
                }
		set rr [string trimleft $rr { }]
		set rr [string trimright $rr {, }]
                yyerror "parse error, expecting: $rr"


                return 1
            }
            lappend state_stack [set state $table($state:error,target)]
            lappend value_stack {}
            # consume tokens until it finds an acceptable one
            while {![info exists table($state:$token)]} {
                if {$token == 0} {
                    yyerror "end of file while recovering from error"
                    return 1
                }
                set yylval {}
                set token [yylex]
                set buflval $yylval
            }
            continue
        }
        switch -- $table($state:$token) {
            shift {
                lappend state_stack $table($state:$token,target)
                lappend value_stack $buflval
                set token ""
            }
            reduce {
                set rule $table($state:$token,target)
                set ll $rules($rule,l)
                if {[info exists rules($rule,e)]} {
                    set dc $rules($rule,e)
                } else {
                    set dc $rules($rule,dc)
                }
                set stackpointer [expr {[llength $state_stack]-$dc}]
                setupvalues $value_stack $stackpointer $dc
                set _ $1
                set yylval [lindex $value_stack end]
                switch -- $rule {
                    1 { ProcessSendCmdGet current hls }
                    2 { ProcessSendCmdYesNo hls lock,$2 }
                    3 { ProcessSendCmdGet hls system }
                    4 { ProcessSendCmdYesNo hls $2 }
                    5 { set _ wcs }
                    6 { set _ crop }
                    7 { set _ slice }
                    8 { set _ bin }
                    9 { set _ axes }
                    10 { set _ scale }
                    11 { set _ scalelimits }
                    12 { set _ colorbar }
                    13 { set _ block }
                    14 { set _ smooth }
                    15 { set _ hue }
                    16 { set _ lightness }
                    17 { set _ saturation }
                }
                unsetupvalues $dc
                # pop off tokens from the stack if normal rule
                if {![info exists rules($rule,e)]} {
                    incr stackpointer -1
                    set state_stack [lrange $state_stack 0 $stackpointer]
                    set value_stack [lrange $value_stack 0 $stackpointer]
                }
                # now do the goto transition
                lappend state_stack $table([lindex $state_stack end]:$ll,target)
                lappend value_stack $_
            }
            accept {
                set accepted 1
            }
            goto -
            default {
                puts stderr "Internal parser error: illegal command $table($state:$token)"
                return 2
            }
        }
    }
    return 0
}

######
# end autogenerated taccle functions
######

proc hlssend::yyerror {msg} {
     variable yycnt
     variable yy_current_buffer
     variable index_

     ParserError $msg $yycnt $yy_current_buffer $index_
}
