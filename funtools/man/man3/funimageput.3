.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "funimageput 3"
.TH funimageput 3 "April 14, 2011" "version 1.4.5" "SAORD Documentation"
.SH "NAME"
FunImagePut \- put an image to a Funtools file
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  #include <funtools.h>
.Ve
.PP
.Vb 2
\&  int FunImagePut(Fun fun, void *buf, int dim1, int dim2, int bitpix,
\&                  char *plist)
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The \fB\f(BIFunImagePut()\fB\fR routine outputs an image array to a \s-1FITS\s0
file. The image is written either as a primary header/data unit or as
an image extension, depending on whether other data have already been
written to the file.  That is, if the current file position is at the
beginning of the file, a primary \s-1HDU\s0 is written. Otherwise, an
image extension is written.
.PP
The first argument is the Funtools handle returned by 
\&\fIFunOpen()\fR.  The second \fBbuf\fR
argument is a pointer to a data buffer to write.  The \fBdim1\fRand
\&\fBdim2\fR arguments that follow specify the dimensions of the image,
where dim1 corresponds to naxis1 and dim2 corresponds to naxis2.  The
\&\fBbitpix\fR argument specifies the data type of the image and can
have the following FITS-standard values:
.IP "\(bu" 4
8 unsigned char
.IP "\(bu" 4
16 short
.IP "\(bu" 4
32 int
.IP "\(bu" 4
\&\-32 float
.IP "\(bu" 4
\&\-64 double
.PP
When \fIFunTableRowPut()\fR is first
called for a given image, Funtools checks to see if the primary header
has already been written (by having previously written an image or a
binary table.) If not, this image is written to the primary \s-1HDU\s0.
Otherwise, it is written to an image extension.
.PP
Thus, a simple program to generate a \s-1FITS\s0 image might look like this:
.PP
.Vb 16
\&  int i;
\&  int dim1=512, dim2=512;
\&  double *dbuf;
\&  Fun fun;
\&  dbuf = malloc(dim1*dim2*sizeof(double));
\&  /* open the output FITS image, preparing to copy input params */
\&  if( !(fun = FunOpen(argv[1], "w", NULL)) )
\&    gerror(stderr, "could not FunOpen output file: %s\en", argv[1]);
\&  for(i=0; i<(dim1*dim2); i++){
\&    ... fill dbuf ...
\&  }
\&  /* put the image (header will be generated automatically */
\&  if( !FunImagePut(fun, buf, dim1, dim2, \-64, NULL) )
\&    gerror(stderr, "could not FunImagePut: %s\en", argv[1]);
\&  FunClose(fun);
\&  free(dbuf);
.Ve
.PP
In addition, if a
Funtools reference handle
was specified when this table was opened, the
parameters from this
Funtools reference handle
are merged into the new image
header.  Furthermore, if a reference image was specified during 
\&\fIFunOpen()\fR, the values of
\&\fBdim1\fR, \fBdim2\fR, and \fBbitpix\fR in the calling sequence
can all be set to 0.  In this case, default values are taken from the
reference image section.  This is useful if you are reading an image
section in its native data format, processing it, and then writing
that section to a new \s-1FITS\s0 file.  See the 
imblank example code.
.PP
The data are assumed to be in the native machine format and will
automatically be swapped to \s-1FITS\s0 big-endian format if necessary.  This
behavior can be over-ridden with the \fBconvert=[true|false]\fR
keyword in the \fBplist\fR param list string.
.PP
When you are finished writing the image, you should call 
\&\fIFunFlush()\fR to write out the \s-1FITS\s0
image padding. However, this is not necessary if you subsequently call
\&\fIFunClose()\fR without doing any other I/O to the \s-1FITS\s0 file.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
See funtools(7) for a list of Funtools help pages
