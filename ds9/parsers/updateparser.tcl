package provide DS9 1.0

######
# Begin autogenerated taccle (version 1.3) routines.
# Although taccle itself is protected by the GNU Public License (GPL)
# all user-supplied functions are protected by their respective
# author's license.  See http://mini.net/tcl/taccle for other details.
######

namespace eval update {
    variable yylval {}
    variable table
    variable rules
    variable token {}
    variable yycnt 0
    variable yyerr 0
    variable save_state 0

    namespace export yylex
}

proc update::YYABORT {} {
    return -code return 1
}

proc update::YYACCEPT {} {
    return -code return 0
}

proc update::YYERROR {} {
    variable yyerr
    set yyerr 1
}

proc update::yyclearin {} {
    variable token
    variable yycnt
    set token {}
    incr yycnt -1
}

proc update::yyerror {s} {
    puts stderr $s
}

proc update::setupvalues {stack pointer numsyms} {
    upvar 1 1 y
    set y {}
    for {set i 1} {$i <= $numsyms} {incr i} {
        upvar 1 $i y
        set y [lindex $stack $pointer]
        incr pointer
    }
}

proc update::unsetupvalues {numsyms} {
    for {set i 1} {$i <= $numsyms} {incr i} {
        upvar 1 $i y
        unset y
    }
}

array set update::table {
  11:264 reduce
  0:257 shift
  13:263 shift
  0:258 shift
  0:259 shift
  0:260 shift
  5:0,target 4
  20:264,target 12
  15:263 shift
  9:0 reduce
  0:266,target 9
  0:261 shift
  2:264,target 5
  11:268 goto
  11:0 reduce
  0:262 shift
  0:263 shift
  14:264,target 17
  0:264 reduce
  19:263 shift
  7:263,target 12
  0:265 shift
  20:264 reduce
  0:266 goto
  2:264 reduce
  0:267 goto
  22:264 reduce
  19:263,target 21
  0:265,target 8
  4:264 reduce
  6:0,target 7
  0:269 goto
  20:0 reduce
  6:264 reduce
  2:0 reduce
  8:263 shift
  8:264 reduce
  5:264,target 4
  6:0 reduce
  0:264,target 11
  17:0,target 10
  0:0,target 11
  10:0,target 0
  0:263,target 7
  8:264,target 13
  12:263,target 15
  3:264,target 3
  8:0,target 13
  3:0 reduce
  1:0,target 2
  11:268,target 14
  11:0,target 8
  0:262,target 6
  12:263 shift
  8:263,target 13
  21:263,target 22
  14:264 shift
  16:263 shift
  18:263 shift
  15:263,target 18
  9:0,target 15
  0:261,target 5
  20:0,target 12
  6:264,target 7
  1:264 reduce
  2:0,target 5
  21:263 shift
  3:264 reduce
  17:0 reduce
  0:0 reduce
  1:264,target 2
  5:264 reduce
  7:263 shift
  0:259,target 3
  0:260,target 4
  22:0 reduce
  0:269,target 11
  4:0 reduce
  9:264 reduce
  3:0,target 3
  18:263,target 20
  9:264,target 15
  8:0 reduce
  10:0 accept
  13:263,target 16
  0:258,target 2
  22:264,target 14
  4:264,target 6
  22:0,target 14
  4:0,target 6
  11:264,target 9
  0:257,target 1
  1:0 reduce
  0:267,target 10
  16:263,target 19
  5:0 reduce
}

array set update::rules {
  9,l 268
  11,l 269
  15,l 269
  2,l 266
  6,l 266
  12,l 269
  3,l 266
  7,l 266
  13,l 269
  0,l 270
  4,l 266
  8,l 267
  10,l 267
  14,l 269
  1,l 266
  5,l 266
}

array set update::rules {
  5,dc 1
  0,dc 1
  12,dc 5
  8,dc 1
  3,dc 1
  15,dc 1
  10,dc 3
  6,dc 1
  1,dc 0
  13,dc 1
  9,dc 0
  4,dc 1
  11,dc 0
  7,dc 1
  2,dc 1
  14,dc 6
}

array set update::rules {
  13,line 50
  7,line 39
  10,line 43
  4,line 36
  1,line 33
  15,line 53
  9,line 42
  12,line 48
  6,line 38
  3,line 35
  14,line 52
  8,line 42
  11,line 46
  5,line 37
  2,line 34
  9,e 1
}

array set update::lr1_table {
  17 {{10 0 3}}
  13,trans {{263 16}}
  0 {{0 0 0} {8 0 0} {10 0 0} {11 {0 264} 0} {12 {0 264} 0} {13 {0 264} 0} {14 {0 264} 0} {15 {0 264} 0} {1 {0 264} 0} {2 {0 264} 0} {3 {0 264} 0} {4 {0 264} 0} {5 {0 264} 0} {6 {0 264} 0} {7 {0 264} 0}}
  18 {{12 {0 264} 4}}
  14,trans {{264 17}}
  1 {{2 {0 264} 1}}
  20 {{12 {0 264} 5}}
  19 {{14 {0 264} 4}}
  15,trans {{263 18}}
  2 {{5 {0 264} 1}}
  21 {{14 {0 264} 5}}
  16,trans {{263 19}}
  3 {{3 {0 264} 1}}
  22 {{14 {0 264} 6}}
  17,trans {}
  0,trans {{257 1} {258 2} {259 3} {260 4} {261 5} {262 6} {263 7} {265 8} {266 9} {267 10} {269 11}}
  4 {{6 {0 264} 1}}
  18,trans {{263 20}}
  1,trans {}
  5 {{4 {0 264} 1}}
  20,trans {}
  19,trans {{263 21}}
  2,trans {}
  6 {{7 {0 264} 1}}
  21,trans {{263 22}}
  3,trans {}
  7 {{12 {0 264} 1}}
  22,trans {}
  4,trans {}
  8 {{13 {0 264} 1} {14 {0 264} 1}}
  5,trans {}
  9 {{15 {0 264} 1}}
  10 {{0 0 1}}
  6,trans {}
  11 {{8 0 1} {10 0 1} {9 264 0}}
  7,trans {{263 12}}
  12 {{12 {0 264} 2}}
  8,trans {{263 13}}
  13 {{14 {0 264} 2}}
  14 {{10 0 2}}
  10,trans {}
  9,trans {}
  15 {{12 {0 264} 3}}
  11,trans {{268 14}}
  16 {{14 {0 264} 3}}
  12,trans {{263 15}}
}

array set update::token_id_table {
  264,line 16
  270,t 1
  269,t 1
  265,title NOW
  261,line 11
  257,t 0
  270,title {}
  269,title {}
  257,line 7
  262,t 0
  270,line 54
  269,line 45
  259,title ON
  260,title OFF
  266,t 1
  264,title string
  error error
  266,line 32
  268,title {}
  error,line 31
  258,t 0
  263,line 14
  error,title {}
  263,t 0
  259,line 9
  260,line 10
  258,title NO
  267,t 1
  263,title integer
  268,line 42
  267,title {}
  257 YES_
  258 NO_
  259,t 0
  259 ON_
  260 OFF_
  260,t 0
  261 TRUE_
  265,line 20
  262 FALSE_
  263 INT_
  257,title YES
  264 STRING_
  264,t 0
  265 NOW_
  262,line 12
  266 yesno
  267 command
  268,t 1
  268 @PSEUDO1
  262,title FALSE
  0 {$}
  0,t 0
  270 start'
  269 update
  error,t 0
  258,line 8
  266,title {}
  261,t 0
  267,line 41
  265,t 0
  261,title TRUE
}

proc update::yyparse {} {
    variable yylval
    variable table
    variable rules
    variable token
    variable yycnt
    variable lr1_table
    variable token_id_table
    variable yyerr
    variable save_state

    set yycnt 0
    set state_stack {0}
    set value_stack {{}}
    set token ""
    set accepted 0
    set yyerr 0
    set save_state 0

    while {$accepted == 0} {
        set state [lindex $state_stack end]
        if {$token == ""} {
            set yylval ""
            set token [yylex]
            set buflval $yylval
	    if {$token>0} {
	        incr yycnt
            }
        }
        if {![info exists table($state:$token)] || $yyerr} {
	    if {!$yyerr} {
	        set save_state $state
	    }
            # pop off states until error token accepted
            while {[llength $state_stack] > 0 && \
                       ![info exists table($state:error)]} {
                set state_stack [lrange $state_stack 0 end-1]
                set value_stack [lrange $value_stack 0 \
                                       [expr {[llength $state_stack] - 1}]]
                set state [lindex $state_stack end]
            }
            if {[llength $state_stack] == 0} {
 
	        set rr { }
                if {[info exists lr1_table($save_state,trans)] && [llength $lr1_table($save_state,trans)] >= 1} {
                    foreach trans $lr1_table($save_state,trans) {
                        foreach {tok_id nextstate} $trans {
			    set ss $token_id_table($tok_id,title)
			    if {$ss != {}} {
			        append rr "$ss, "
                            }
                        }
                    }
                }
		set rr [string trimleft $rr { }]
		set rr [string trimright $rr {, }]
                yyerror "parse error, expecting: $rr"


                return 1
            }
            lappend state_stack [set state $table($state:error,target)]
            lappend value_stack {}
            # consume tokens until it finds an acceptable one
            while {![info exists table($state:$token)]} {
                if {$token == 0} {
                    yyerror "end of file while recovering from error"
                    return 1
                }
                set yylval {}
                set token [yylex]
                set buflval $yylval
            }
            continue
        }
        switch -- $table($state:$token) {
            shift {
                lappend state_stack $table($state:$token,target)
                lappend value_stack $buflval
                set token ""
            }
            reduce {
                set rule $table($state:$token,target)
                set ll $rules($rule,l)
                if {[info exists rules($rule,e)]} {
                    set dc $rules($rule,e)
                } else {
                    set dc $rules($rule,dc)
                }
                set stackpointer [expr {[llength $state_stack]-$dc}]
                setupvalues $value_stack $stackpointer $dc
                set _ $1
                set yylval [lindex $value_stack end]
                switch -- $rule {
                    1 { set _ 1 }
                    2 { set _ 1 }
                    3 { set _ 1 }
                    4 { set _ 1 }
                    5 { set _ 0 }
                    6 { set _ 0 }
                    7 { set _ 0 }
                    9 { global ds9; if {!$ds9(init)} {YYERROR} else {yyclearin; YYACCEPT} }
                    11 { UpdateCmd }
                    12 { UpdateCmd $1 $2 $3 $4 $5 }
                    13 { UpdateCmd }
                    14 { UpdateCmd $2 $3 $4 $5 $6 }
                }
                unsetupvalues $dc
                # pop off tokens from the stack if normal rule
                if {![info exists rules($rule,e)]} {
                    incr stackpointer -1
                    set state_stack [lrange $state_stack 0 $stackpointer]
                    set value_stack [lrange $value_stack 0 $stackpointer]
                }
                # now do the goto transition
                lappend state_stack $table([lindex $state_stack end]:$ll,target)
                lappend value_stack $_
            }
            accept {
                set accepted 1
            }
            goto -
            default {
                puts stderr "Internal parser error: illegal command $table($state:$token)"
                return 2
            }
        }
    }
    return 0
}

######
# end autogenerated taccle functions
######

proc update::yyerror {msg} {
     variable yycnt
     variable yy_current_buffer
     variable index_

     ParserError $msg $yycnt $yy_current_buffer $index_
}
