.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "funlib 3"
.TH funlib 3 "April 14, 2011" "version 1.4.5" "SAORD Documentation"
.SH "NAME"
FunLib \- the Funtools Programming Interface
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
A description of the Funtools library.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\fBIntroduction to the Funtools Programming Interface\fR
.PP
To create a Funtools application, you need to include
the funtools.h definitions file in your code:
.PP
.Vb 1
\&  #include <funtools.h>
.Ve
.PP
You then call Funtools subroutines and functions to access Funtools data.
The most important routines are:
.IP "\(bu" 4
FunOpen: open a Funtools file
.IP "\(bu" 4
FunInfoGet: get info about an image or table
.IP "\(bu" 4
FunImageGet: retrieve image data
.IP "\(bu" 4
FunImageRowGet: retrieve image data by row
.IP "\(bu" 4
FunImagePut: output image data
.IP "\(bu" 4
FunImageRowPut: output image data by row
.IP "\(bu" 4
FunColumnSelect: select columns in a table for access
.IP "\(bu" 4
FunTableRowGet: retrieve rows from a table
.IP "\(bu" 4
FunTableRowPut: output rows to a table
.IP "\(bu" 4
FunClose: close a Funtools file
.PP
Your program must be linked against the libfuntools.a library,
along with the math library. The following libraries also might be required
on your system:
.IP "\(bu" 4
\&\-lsocket \-lnsl for socket support
.IP "\(bu" 4
\&\-ldl           for dynamic loading
.PP
For example, on a Solaris system using gcc, use the following link line:
.PP
.Vb 1
\&  gcc \-o foo foo.c \-lfuntools \-lsocket \-lnsl \-ldl \-lm
.Ve
.PP
On a Solaris system using Solaris cc, use the following link line:
.PP
.Vb 1
\&  gcc \-o foo foo.c \-lfuntools \-lsocket \-lnsl \-lm
.Ve
.PP
On a Linux system using gcc, use the following link line:
.PP
.Vb 1
\&  gcc \-o foo foo.c \-lfuntools \-ldl \-lm
.Ve
.PP
Once configure has built a Makefile on your platform, the required
\&\*(L"extra\*(R" libraries (aside from \-lm, which always is required) are
specified in that file's \s-1EXTRA_LIBS\s0 variable. For example, under
Linux you will find:
.PP
.Vb 3
\&  grep EXTRA_LIBS Makefile
\&  EXTRA_LIBS      =  \-ldl
\&  ...
.Ve
.PP
The Funtools library contains both the zlib library
(http://www.gzip.org/zlib/) and Doug Mink's \s-1WCS\s0 library
(http://tdc\-www.harvard.edu/software/wcstools/).  It is not necessary
to put these libraries on a Funtools link line. Include files
necessary for using these libraries are installed in the Funtools
include directory.
.PP
\&\fBFuntools Programming Tutorial\fR
.PP
The
\&\fIFunOpen()\fR
function is used to open a \s-1FITS\s0 file, an array, or a raw event file:
.PP
.Vb 4
\&  /* open the input FITS file for reading */
\&  ifun = FunOpen(iname, "r", NULL);
\&  /* open the output FITS file for writing, and connect it to the input file */
\&  ofun = FunOpen(iname, "w", ifun);
.Ve
.PP
A new output file can inherit header parameters automatically from
existing input file by passing the input Funtools handle as the last
argument to the new file's
\&\fIFunOpen()\fR
call as shown above.
.PP
For image data, you then can call
\&\fIFunImageGet()\fR
to read an image into memory.
.PP
.Vb 3
\&  float buf=NULL;
\&  /* extract and bin the data section into an image buffer */
\&  buf = FunImageGet(fun, NULL, "bitpix=-32");
.Ve
.PP
If the (second) buf argument to this call is \s-1NULL\s0, buffer space is allocated
automatically. The (third) plist argument can be used to specify the
return data type of the array.  If \s-1NULL\s0 is specified, the data type of
the input file is used.
.PP
To process an image buffer, you would generally make a call to 
\&\fIFunInfoGet()\fR to determine the
dimensions of the image (which may have been changed from the original
file dimensions due to Funtools image
sectioning on the command line). In a \s-1FITS\s0 image, the index along
the dim1 axis varies most rapidly, followed by the dim2 axis, etc.
Thus, to access each pixel in an 2D image, use a double loop such as:
.PP
.Vb 7
\&  buf = FunImageGet(fun, NULL, "bitpix=-32");
\&  FunInfoGet(fun, FUN_SECT_DIM1, &dim1, FUN_SECT_DIM2, &dim2, 0);
\&  for(i=1; i<=dim2; i++){
\&    for(j=1; j<=dim1; j++){
\&      ... process buf[((i-1)*dim1)+(j-1)] ...
\&    }
\&  }
.Ve
.PP
or:
.PP
.Vb 5
\&  buf = FunImageGet(fun, NULL, "bitpix=-32");
\&  FunInfoGet(fun, FUN_SECT_DIM1, &dim1, FUN_SECT_DIM2, &dim2, 0);
\&  for(i=0; i<(dim1*dim2); i++){
\&    ... process buf[i] ...
\&  }
.Ve
.PP
Finally, you can write the resulting image to disk using
\&\fIFunImagePut()\fR:
.PP
.Vb 1
\&  FunImagePut(fun2, buf, dim1, dim2, \-32, NULL);
.Ve
.PP
Note that Funtools automatically takes care of book-keeping tasks such as
reading and writing \s-1FITS\s0 headers (although you can, of course, write
your own header or add your own parameters to a header).
.PP
For binary tables and raw event files, a call to
\&\fIFunOpen()\fR
will be followed by a call to the
\&\fIFunColumnSelect()\fR
routine to select columns to be read from the input file and/or
written to the output file:
.PP
.Vb 8
\&  typedef struct evstruct{
\&    double time;
\&    int time2;
\&  } *Ev, EvRec;
\&  FunColumnSelect(fun, sizeof(EvRec), NULL,
\&                  "time",      "D",     "rw",  FUN_OFFSET(Ev, time),
\&                  "time2",     "J",     "w",   FUN_OFFSET(Ev, time2),
\&                  NULL);
.Ve
.PP
Columns whose (third) mode argument contains an \*(L"r\*(R" are \*(L"readable\*(R",
i.e., columns will be read from the input file and converted into the
data type specified in the call's second argument. These columns
values then are stored in the specified offset of the user record
structure.  Columns whose mode argument contains a \*(L"w\*(R" are
\&\*(L"writable\*(R", i.e., these values will be written to the output file.
The
\&\fIFunColumnSelect()\fR
routine also offers the option of automatically merging user
columns with the original input columns when writing the output
rows.
.PP
Once a set of columns has been specified, you can retrieve rows using
\&\fIFunTableRowGet()\fR,
and write the rows using
\&\fIFunTableRowPut()\fR:
.PP
.Vb 17
\&  Ev ebuf, ev;
\&  /* get rows -- let routine allocate the array */
\&  while( (ebuf = (Ev)FunTableRowGet(fun, NULL, MAXROW, NULL, &got)) ){
\&    /* process all rows */
\&    for(i=0; i<got; i++){
\&      /* point to the i'th row */
\&      ev = ebuf+i;
\&      /* time2 is generated here */
\&      ev->time2 = (int)(ev->time+.5);
\&      /* change the input time as well */
\&      ev->time = -(ev->time/10.0);
\&    }
\&    /* write out this batch of rows with the new column */
\&    FunTableRowPut(fun2, (char *)ebuf, got, 0, NULL);
\&    /* free row data */
\&    if( ebuf ) free(ebuf);
\&  }
.Ve
.PP
The input rows are retrieved into an array of user structs, which
can be accessed serially as shown above. Once again, Funtools
automatically takes care of book-keeping tasks such as reading and writing
\&\s-1FITS\s0 headers (although you can, of course, write your own header or
add your own parameters to a header).
.PP
When all processing is done, you can call
\&\fIFunClose()\fR
to close the file(s):
.PP
.Vb 2
\&  FunClose(fun2);
\&  FunClose(fun);
.Ve
.PP
These are the basics of processing \s-1FITS\s0 files (and arrays or raw event
data) using Funtools. The routines in these examples are described in
more detail below, along with a few other routines that support
parameter access, data flushing, etc.
.PP
\&\fBCompiling and Linking\fR
.PP
To create a Funtools application, a software developer will include
the funtools.h definitions file in Funtools code:
.PP
.Vb 1
\&  #include <funtools.h>
.Ve
.PP
The program is linked against the libfuntools.a library, along with the
math library (and the dynamic load library, if the latter is available
on your system):
.PP
.Vb 1
\&  gcc \-o foo foo.c \-lfuntools \-ldl \-lm
.Ve
.PP
If gcc is used, Funtools filtering can be performed using dynamically
loaded shared objects that are built at run\-time. Otherwise, filtering
is performed using a slave process.
.PP
Funtools has been built on the following systems:
.IP "\(bu" 4
Sun/Solaris 5.X
.IP "\(bu" 4
Linux/RedHat Linux 5.X,6.X,7.X
.IP "\(bu" 4
Dec Alpha/OSF1 V4.X
.IP "\(bu" 4
WindowsNT/Cygwin 1.0
.IP "\(bu" 4
\&\s-1SGI/IRIX64\s0 6.5
.PP
\&\fBA Short Digression on Subroutine Order\fR
.PP
There is a natural order for all I/O access libraries. You would not
think of reading a file without first opening it, or writing a file
after closing it. A large part of the experiment in funtools is to use
the idea of \*(L"natural order\*(R" as a means of making programming
easier. We do this by maintaining the state of processing for a given
funtools file, so that we can do things like write headers and flush
extension padding at the right time, without you having to do it.
.PP
For example, if you open a new funtools file for writing using
\&\fIFunOpen()\fR,
then generate an array of image data and call
\&\fIFunImagePut()\fR,
funtools knows to write the image header automatically.
There is no need to think about writing a standard header.
Of course, you can add parameters to the file first by
calling one of the
\&\fIFunParamPut()\fR
routines, and these parameters will automatically be added
to the header when it is written out.  There still is no
need to write the header explicitly.
.PP
Maintaining state in this way means that there are certain rules of
order which should be maintained in any funtools program. In particular,
we strongly recommend the following ordering rules be adhered to:
.IP "\(bu" 4
When specifying that input extensions be copied to an output file
via a reference handle, open the output file \fBbefore\fR reading the
input file. (Otherwise the initial copy will not occur).
.IP "\(bu" 4
Always write parameters to an output file using one of the
\&\fIFunParamPut()\fR calls
\&\fBbefore\fR writing any data. (This is a good idea for all \s-1FITS\s0
libraries, to avoid having to recopy data is the \s-1FITS\s0 header needs
to be extended by adding a single parameter.)
.IP "\(bu" 4
If you retrieve an image, and need to know the data
type, use the \s-1FUN_SECT_BITPIX\s0 option of
\&\fIFunInfoGet()\fR,
\&\fBafter\fR calling
\&\fIFunImageGet()\fR, since
it is possible to change the value of \s-1BITPIX\s0 from the latter.
.IP "\(bu" 4
When specifying that input extensions be copied to an output file
via a reference handle, close the output file \fBbefore\fR closing
input file, or else use
\&\fIFunFlush()\fR
explicitly on the output file
\&\fBbefore\fR closing the input file. (Otherwise the final copy will
not occur).
.PP
We believe that these are the natural rules that are implied in most
\&\s-1FITS\s0 programming tasks. However, we recognize that making explicit use
of \*(L"natural order\*(R" to decide what automatic action to take on behalf
of the programmer is experimental.  Therefore, if you find that your
needs are not compatible with our preferred order, please let us know
\&\*(-- it will be most illuminating for us as we evaluate this experiment.
.PP
\&\fBFuntools Programming Examples\fR
.PP
The following complete coding examples are provided to illustrate the
simplicity of Funtools applications.  They can be found in the funtest
subdirectory of the Funtools distribution.  In many cases, you should
be able to modify one of these programs to generate your own Funtools
program:
.IP "\(bu" 4
evread.c: read and write binary tables
.IP "\(bu" 4
evcols.c: add column and rows to binary tables
.IP "\(bu" 4
evmerge.c: merge new columns with existing columns
.IP "\(bu" 4
evnext.c: manipulate raw data pointers
.IP "\(bu" 4
imblank.c: blank out image values below a threshold
.IP "\(bu" 4
asc2fits.c: convert a specific \s-1ASCII\s0 table to \s-1FITS\s0 binary table
.PP
\&\fBThe Funtools Programming Reference Manual\fR
.PP
#include <funtools.h>
.PP
Fun FunOpen(char *name, char *mode, Fun ref)
.PP
void *FunImageGet(Fun fun, void *buf, char *plist)
.PP
int FunImagePut(Fun fun, void *buf, int dim1, int dim2, int bitpix, char *plist)
.PP
void * FunImageRowGet(Fun fun, void *buf, int rstart, int rstop, char *plist)
.PP
void * FunImageRowPut(Fun fun, void *buf, int rstart, int rstop, int dim1, int dim2, int bitpix, char *plist)
.PP
int FunColumnSelect(Fun fun, int size, char *plist, ...)
.PP
void FunColumnActivate(Fun fun, char *s, char *plist)
.PP
int FunColumnLookup(Fun fun, char *s, int which, char **name, int *type, int *mode, int *offset, int *n, int *width)
.PP
void *FunTableRowGet(Fun fun, void *rows, int maxrow, char *plist, int *nrow)
.PP
int FunTableRowPut(Fun fun, void *rows, int nev, int idx, char *plist)
.PP
int FunParamGetb(Fun fun, char *name, int n, int defval, int *got)
.PP
int FunParamGeti(Fun fun, char *name, int n, int defval, int *got)
.PP
double FunParamGetd(Fun fun, char *name, int n, double defval, int *got)
.PP
char *FunParamGets(Fun fun, char *name, int n, char *defval, int *got)
.PP
int FunParamPutb(Fun fun, char *name, int n, int value, char *comm, int append)
.PP
int FunParamPuti(Fun fun, char *name, int n, int value, char *comm, int append)
.PP
int FunParamPutd(Fun fun, char *name, int n, double value, int prec, char *comm, int append)
.PP
int FunParamPuts(Fun fun, char *name, int n, char *value, char *comm, int append)
.PP
int FunInfoGet(Fun fun, int type, ...)
.PP
int FunInfoPut(Fun fun, int type, ...)
.PP
void FunFlush(Fun fun, char *plist)
.PP
void FunClose(Fun fun)
.SH "SEE ALSO"
.IX Header "SEE ALSO"
See funtools(7) for a list of Funtools help pages
