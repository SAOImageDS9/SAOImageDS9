package provide DS9 1.0

######
# Begin autogenerated taccle (version 1.3) routines.
# Although taccle itself is protected by the GNU Public License (GPL)
# all user-supplied functions are protected by their respective
# author's license.  See http://mini.net/tcl/taccle for other details.
######

namespace eval illustrate {
    variable yylval {}
    variable table
    variable rules
    variable token {}
    variable yycnt 0
    variable yyerr 0
    variable save_state 0

    namespace export yylex
}

proc illustrate::YYABORT {} {
    return -code return 1
}

proc illustrate::YYACCEPT {} {
    return -code return 0
}

proc illustrate::YYERROR {} {
    variable yyerr
    set yyerr 1
}

proc illustrate::yyclearin {} {
    variable token
    variable yycnt
    set token {}
    incr yycnt -1
}

proc illustrate::yyerror {s} {
    puts stderr $s
}

proc illustrate::setupvalues {stack pointer numsyms} {
    upvar 1 1 y
    set y {}
    for {set i 1} {$i <= $numsyms} {incr i} {
        upvar 1 $i y
        set y [lindex $stack $pointer]
        incr pointer
    }
}

proc illustrate::unsetupvalues {numsyms} {
    for {set i 1} {$i <= $numsyms} {incr i} {
        upvar 1 $i y
        unset y
    }
}

array set illustrate::table {
  6:265,target 7
  3:0,target 14
  0:289,target 4
  7:0 reduce
  0:276 shift
  5:290 goto
  5:0,target 10
  0:277 shift
  1:265,target 15
  7:0,target 12
  0:276,target 2
  3:265,target 14
  5:265,target 11
  2:0,target 13
  1:265 reduce
  4:0,target 0
  2:265 reduce
  0:291,target 5
  0:273,target 1
  3:265 reduce
  1:0 reduce
  5:265 reduce
  2:265,target 13
  2:0 reduce
  6:265 shift
  5:290,target 6
  3:0 reduce
  0:289 goto
  0:277,target 3
  4:0 accept
  1:0,target 15
  0:291 goto
  0:273 shift
  5:0 reduce
}

array set illustrate::rules {
  9,l 288
  11,l 290
  15,l 291
  2,l 287
  6,l 287
  12,l 289
  3,l 287
  7,l 287
  13,l 291
  0,l 292
  4,l 287
  8,l 288
  10,l 289
  14,l 291
  1,l 287
  5,l 287
}

array set illustrate::rules {
  5,dc 1
  0,dc 1
  12,dc 3
  8,dc 1
  3,dc 1
  15,dc 1
  10,dc 1
  6,dc 1
  1,dc 0
  13,dc 1
  9,dc 1
  4,dc 1
  11,dc 0
  7,dc 1
  2,dc 1
  14,dc 1
}

array set illustrate::rules {
  13,line 74
  7,line 64
  10,line 70
  4,line 61
  1,line 58
  15,line 76
  9,line 67
  12,line 71
  6,line 63
  3,line 60
  14,line 75
  8,line 66
  11,line 70
  5,line 62
  2,line 59
  11,e 1
}

array set illustrate::lr1_table {
  0 {{0 0 0} {10 0 0} {12 0 0} {13 {0 265} 0} {14 {0 265} 0} {15 {0 265} 0}}
  1 {{15 {0 265} 1}}
  2 {{13 {0 265} 1}}
  3 {{14 {0 265} 1}}
  4 {{0 0 1}}
  0,trans {{273 1} {276 2} {277 3} {289 4} {291 5}}
  5 {{10 0 1} {12 0 1} {11 265 0}}
  1,trans {}
  2,trans {}
  6 {{12 0 2}}
  7 {{12 0 3}}
  3,trans {}
  4,trans {}
  5,trans {{290 6}}
  6,trans {{265 7}}
  7,trans {}
}

array set illustrate::token_id_table {
  286,t 0
  286 TEXT_
  280,title WIDTH
  279,title SHAPE
  264,line 15
  292,line 77
  287 yesno
  270,t 0
  269,t 0
  288 numeric
  290 @PSEUDO1
  289 command
  276,line 31
  265,title string
  291,t 1
  291 illustrate
  284,title POLYGON
  292 start'
  274,t 0
  261,line 11
  288,line 65
  257,t 0
  270,title DELETE
  269,title DASH
  288,title {}
  273,line 28
  278,t 0
  257,line 7
  262,t 0
  285,line 41
  274,title MOVE
  283,t 0
  270,line 25
  269,line 24
  259,title ON
  260,title OFF
  266,t 0
  278,title SELECTION
  282,line 38
  287,t 1
  error error
  271,t 0
  264,title float
  266,line 21
  283,title BOX
  292,t 1
  278,line 33
  error,line 56
  275,t 0
  268,title COLOR
  287,title {}
  258,t 0
  263,line 14
  291,line 73
  error,title {}
  280,t 0
  279,t 0
  275,line 30
  273,title LIST
  292,title {}
  263,t 0
  259,line 9
  260,line 10
  287,line 57
  258,title NO
  284,t 0
  277,title SAVE
  272,line 27
  267,t 0
  263,title integer
  288,t 1
  284,line 40
  282,title ELLIPSE
  272,t 0
  268,line 23
  267,title BACK
  286,title TEXT
  257 YES_
  281,line 37
  276,t 0
  258 NO_
  259,t 0
  259 ON_
  260 OFF_
  260,t 0
  272,title INVERT
  261 TRUE_
  265,line 17
  291,title {}
  262 FALSE_
  281,t 0
  263 INT_
  277,line 32
  257,title YES
  264 REAL_
  264,t 0
  276,title OPEN
  265 STRING_
  262,line 12
  266 ALL_
  290,line 70
  289,line 69
  285,t 0
  267 BACK_
  0,t 0
  0 {$}
  262,title FALSE
  268 COLOR_
  268,t 0
  281,title CIRCLE
  274,line 29
  270 DELETE_
  269 DASH_
  error,t 0
  271 FRONT_
  290,t 1
  289,t 1
  272 INVERT_
  258,line 8
  286,line 42
  273,t 0
  273 LIST_
  266,title ALL
  285,title LINE
  274 MOVE_
  275 NONE_
  271,line 26
  276 OPEN_
  277,t 0
  277 SAVE_
  271,title FRONT
  290,title {}
  289,title {}
  283,line 39
  278 SELECTION_
  261,t 0
  280 WIDTH_
  279 SHAPE_
  281 CIRCLE_
  267,line 22
  282,t 0
  282 ELLIPSE_
  275,title NONE
  283 BOX_
  265,t 0
  284 POLYGON_
  280,line 35
  279,line 34
  285 LINE_
  261,title TRUE
}

proc illustrate::yyparse {} {
    variable yylval
    variable table
    variable rules
    variable token
    variable yycnt
    variable lr1_table
    variable token_id_table
    variable yyerr
    variable save_state

    set yycnt 0
    set state_stack {0}
    set value_stack {{}}
    set token ""
    set accepted 0
    set yyerr 0
    set save_state 0

    while {$accepted == 0} {
        set state [lindex $state_stack end]
        if {$token == ""} {
            set yylval ""
            set token [yylex]
            set buflval $yylval
	    if {$token>0} {
	        incr yycnt
            }
        }
        if {![info exists table($state:$token)] || $yyerr} {
	    if {!$yyerr} {
	        set save_state $state
	    }
            # pop off states until error token accepted
            while {[llength $state_stack] > 0 && \
                       ![info exists table($state:error)]} {
                set state_stack [lrange $state_stack 0 end-1]
                set value_stack [lrange $value_stack 0 \
                                       [expr {[llength $state_stack] - 1}]]
                set state [lindex $state_stack end]
            }
            if {[llength $state_stack] == 0} {
 
	        set rr { }
                if {[info exists lr1_table($save_state,trans)] && [llength $lr1_table($save_state,trans)] >= 1} {
                    foreach trans $lr1_table($save_state,trans) {
                        foreach {tok_id nextstate} $trans {
			    set ss $token_id_table($tok_id,title)
			    if {$ss != {}} {
			        append rr "$ss, "
                            }
                        }
                    }
                }
		set rr [string trimleft $rr { }]
		set rr [string trimright $rr {, }]
                yyerror "parse error, expecting: $rr"


                return 1
            }
            lappend state_stack [set state $table($state:error,target)]
            lappend value_stack {}
            # consume tokens until it finds an acceptable one
            while {![info exists table($state:$token)]} {
                if {$token == 0} {
                    yyerror "end of file while recovering from error"
                    return 1
                }
                set yylval {}
                set token [yylex]
                set buflval $yylval
            }
            continue
        }
        switch -- $table($state:$token) {
            shift {
                lappend state_stack $table($state:$token,target)
                lappend value_stack $buflval
                set token ""
            }
            reduce {
                set rule $table($state:$token,target)
                set ll $rules($rule,l)
                if {[info exists rules($rule,e)]} {
                    set dc $rules($rule,e)
                } else {
                    set dc $rules($rule,dc)
                }
                set stackpointer [expr {[llength $state_stack]-$dc}]
                setupvalues $value_stack $stackpointer $dc
                set _ $1
                set yylval [lindex $value_stack end]
                switch -- $rule {
                    1 { set _ 1 }
                    2 { set _ 1 }
                    3 { set _ 1 }
                    4 { set _ 1 }
                    5 { set _ 0 }
                    6 { set _ 0 }
                    7 { set _ 0 }
                    8 { set _ $1 }
                    9 { set _ $1 }
                    11 { global ds9; if {!$ds9(init)} {YYERROR} else {yyclearin; YYACCEPT} }
                }
                unsetupvalues $dc
                # pop off tokens from the stack if normal rule
                if {![info exists rules($rule,e)]} {
                    incr stackpointer -1
                    set state_stack [lrange $state_stack 0 $stackpointer]
                    set value_stack [lrange $value_stack 0 $stackpointer]
                }
                # now do the goto transition
                lappend state_stack $table([lindex $state_stack end]:$ll,target)
                lappend value_stack $_
            }
            accept {
                set accepted 1
            }
            goto -
            default {
                puts stderr "Internal parser error: illegal command $table($state:$token)"
                return 2
            }
        }
    }
    return 0
}

######
# end autogenerated taccle functions
######

proc illustrate::yyerror {msg} {
     variable yycnt
     variable yy_current_buffer
     variable index_

     ParserError $msg $yycnt $yy_current_buffer $index_
}
