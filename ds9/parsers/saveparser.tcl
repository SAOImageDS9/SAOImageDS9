package provide DS9 1.0

######
# Begin autogenerated taccle (version 1.3) routines.
# Although taccle itself is protected by the GNU Public License (GPL)
# all user-supplied functions are protected by their respective
# author's license.  See http://mini.net/tcl/taccle for other details.
######

namespace eval save {
    variable yylval {}
    variable table
    variable rules
    variable token {}
    variable yycnt 0
    variable yyerr 0
    variable save_state 0

    namespace export yylex
}

proc save::YYABORT {} {
    return -code return 1
}

proc save::YYACCEPT {} {
    return -code return 0
}

proc save::YYERROR {} {
    variable yyerr
    set yyerr 1
}

proc save::yyclearin {} {
    variable token
    variable yycnt
    set token {}
    incr yycnt -1
}

proc save::yyerror {s} {
    puts stderr $s
}

proc save::setupvalues {stack pointer numsyms} {
    upvar 1 1 y
    set y {}
    for {set i 1} {$i <= $numsyms} {incr i} {
        upvar 1 $i y
        set y [lindex $stack $pointer]
        incr pointer
    }
}

proc save::unsetupvalues {numsyms} {
    for {set i 1} {$i <= $numsyms} {incr i} {
        upvar 1 $i y
        unset y
    }
}

array set save::table {
  27:272,target 20
  17:258 reduce
  0:258 shift
  1:281,target 23
  23:0,target 4
  15:258,target 2
  0:260 shift
  0:259 shift
  27:0 reduce
  20:258 reduce
  19:258 reduce
  15:0,target 1
  2:258 reduce
  0:261 shift
  0:266,target 9
  0:262 shift
  22:258 reduce
  10:258,target 16
  4:258 reduce
  0:263 shift
  0:264 shift
  29:258,target 5
  24:258 reduce
  6:258 reduce
  0:265 shift
  15:0 reduce
  0:266 shift
  27:281,target 29
  26:258 shift
  8:258 reduce
  0:267 shift
  24:258,target 17
  6:258,target 10
  0:265,target 8
  0:268 shift
  0:275,target 14
  0:269 shift
  0:270 shift
  20:0 reduce
  19:0 reduce
  18:258,target 15
  1:258,target 22
  15:276 goto
  13:258,target 21
  0:275 goto
  0:264,target 7
  15:276,target 26
  0:277 goto
  0:278 goto
  28:0 reduce
  1:257,target 19
  0:279 goto
  0:280 goto
  27:258,target 22
  9:258,target 13
  22:258,target 25
  4:258,target 8
  0:263,target 6
  10:258 reduce
  16:258,target 27
  27:257,target 19
  12:258 reduce
  21:0 reduce
  11:258,target 18
  1:0,target 22
  0:262,target 5
  16:258 shift
  1:257 shift
  18:258 reduce
  1:258 reduce
  25:258,target 20
  7:258,target 11
  21:258 reduce
  3:258 reduce
  29:0 reduce
  10:271 shift
  27:0,target 22
  23:258 reduce
  20:258,target 23
  19:258,target 26
  5:258 reduce
  2:258,target 6
  0:261,target 4
  20:0,target 23
  19:0,target 26
  12:271 shift
  25:258 reduce
  7:258 reduce
  27:257 shift
  27:258 reduce
  12:271,target 25
  9:258 reduce
  1:274,target 22
  29:258 reduce
  0:259,target 2
  0:260,target 3
  22:0 reduce
  0:269,target 12
  0:270,target 13
  1:272 shift
  28:0,target 3
  0:279,target 17
  0:280,target 18
  1:273 shift
  21:0,target 24
  1:274 shift
  23:258,target 4
  5:258,target 9
  1:273,target 21
  27:274,target 22
  17:258,target 14
  0:258,target 1
  0:268,target 11
  27:272 shift
  0:278,target 16
  1:281 goto
  27:273 shift
  14:0 accept
  12:258,target 19
  29:0,target 5
  27:274 shift
  10:271,target 24
  22:0,target 25
  1:272,target 20
  27:273,target 21
  14:0,target 0
  11:258 reduce
  1:0 reduce
  26:258,target 28
  8:258,target 12
  0:267,target 10
  13:258 reduce
  0:277,target 15
  27:281 goto
  23:0 reduce
  21:258,target 24
  15:258 reduce
  3:258,target 7
}

array set save::rules {
  9,l 278
  11,l 278
  15,l 278
  20,l 280
  19,l 280
  2,l 276
  24,l 281
  6,l 278
  12,l 278
  16,l 279
  21,l 280
  3,l 275
  25,l 281
  7,l 278
  13,l 278
  0,l 282
  17,l 279
  22,l 281
  4,l 277
  26,l 281
  8,l 278
  10,l 278
  14,l 278
  18,l 279
  1,l 275
  23,l 281
  5,l 277
}

array set save::rules {
  23,dc 1
  5,dc 3
  0,dc 1
  17,dc 2
  12,dc 1
  26,dc 1
  8,dc 1
  21,dc 1
  3,dc 3
  15,dc 1
  10,dc 1
  24,dc 1
  6,dc 1
  18,dc 1
  1,dc 1
  13,dc 1
  9,dc 1
  22,dc 0
  4,dc 2
  16,dc 1
  11,dc 1
  25,dc 1
  7,dc 1
  20,dc 2
  19,dc 1
  2,dc 0
  14,dc 1
}

array set save::rules {
  13,line 49
  25,line 67
  2,e 1
  7,line 43
  10,line 46
  22,line 64
  4,line 38
  18,line 56
  1,line 34
  15,line 51
  9,line 45
  12,line 48
  24,line 66
  6,line 42
  21,line 61
  3,line 35
  17,line 55
  14,line 50
  26,line 68
  8,line 44
  11,line 47
  23,line 65
  5,line 39
  20,line 60
  19,line 59
  2,line 34
  16,line 54
}

array set save::lr1_table {
  14,trans {}
  1,trans {{257 19} {272 20} {273 21} {274 22} {281 23}}
  18,trans {}
  23,trans {}
  5,trans {}
  27,trans {{257 19} {272 20} {273 21} {274 22} {281 29}}
  9,trans {}
  13,trans {}
  0,trans {{258 1} {259 2} {260 3} {261 4} {262 5} {263 6} {264 7} {265 8} {266 9} {267 10} {268 11} {269 12} {270 13} {275 14} {277 15} {278 16} {279 17} {280 18}}
  17,trans {}
  22,trans {}
  4,trans {}
  26,trans {{258 28}}
  8,trans {}
  12,trans {{271 25}}
  16,trans {{258 27}}
  21,trans {}
  3,trans {}
  10 {{16 258 1} {17 258 1}}
  11 {{18 258 1}}
  25,trans {}
  12 {{19 258 1} {20 258 1}}
  7,trans {}
  13 {{21 258 1}}
  14 {{0 0 1}}
  15 {{1 0 1} {3 0 1} {2 258 0}}
  11,trans {}
  29,trans {}
  16 {{5 {0 258} 1}}
  0 {{0 0 0} {1 0 0} {3 0 0} {4 {0 258} 0} {5 {0 258} 0} {6 258 0} {7 258 0} {8 258 0} {9 258 0} {10 258 0} {11 258 0} {12 258 0} {13 258 0} {14 258 0} {15 258 0} {16 258 0} {17 258 0} {18 258 0} {19 258 0} {20 258 0} {21 258 0}}
  17 {{14 258 1}}
  1 {{4 {0 258} 1} {22 {0 258} 0} {23 {0 258} 0} {24 {0 258} 0} {25 {0 258} 0} {26 {0 258} 0}}
  18 {{15 258 1}}
  2 {{6 258 1}}
  19 {{26 {0 258} 1}}
  20 {{23 {0 258} 1}}
  15,trans {{276 26}}
  3 {{7 258 1}}
  21 {{24 {0 258} 1}}
  4 {{8 258 1}}
  22 {{25 {0 258} 1}}
  5 {{9 258 1}}
  23 {{4 {0 258} 2}}
  20,trans {}
  6 {{10 258 1}}
  2,trans {}
  24 {{17 258 2}}
  19,trans {}
  7 {{11 258 1}}
  25 {{20 258 2}}
  8 {{12 258 1}}
  26 {{3 0 2}}
  9 {{13 258 1}}
  27 {{5 {0 258} 2} {22 {0 258} 0} {23 {0 258} 0} {24 {0 258} 0} {25 {0 258} 0} {26 {0 258} 0}}
  28 {{3 0 3}}
  24,trans {}
  6,trans {}
  29 {{5 {0 258} 3}}
  10,trans {{271 24}}
  28,trans {}
}

array set save::token_id_table {
  280,title {}
  279,title {}
  264,line 18
  270,t 0
  269,t 0
  276,line 34
  265,title HSVCUBE
  274,t 0
  261,line 15
  257,t 0
  270,title MOSAICIMAGEWCS
  269,title MOSAICIMAGE
  273,line 28
  278,t 1
  257,line 7
  262,t 0
  274,title SLICE
  270,line 24
  269,line 23
  259,title FITS
  260,title RGBIMAGE
  266,t 0
  278,title {}
  282,line 69
  error error
  271,t 0
  264,title HSVIMAGE
  266,line 20
  278,line 41
  275,t 1
  error,line 32
  268,title MOSAICWCS
  258,t 0
  263,line 17
  error,title {}
  280,t 1
  279,t 1
  275,line 33
  273,title TABLE
  263,t 0
  259,line 13
  260,line 14
  258,title string
  277,title {}
  272,line 27
  267,t 0
  263,title HLSCUBE
  282,title {}
  272,t 0
  268,line 22
  267,title MOSAIC
  257 INT_
  281,line 63
  276,t 1
  258 STRING_
  259,t 0
  259 FITS_
  260 RGBIMAGE_
  260,t 0
  272,title IMAGE
  261 RGBCUBE_
  265,line 19
  262 HLSIMAGE_
  281,t 1
  263 HLSCUBE_
  277,line 37
  257,title integer
  264 HSVIMAGE_
  264,t 0
  276,title {}
  265 HSVCUBE_
  262,line 16
  266 MECUBE_
  267 MOSAIC_
  0,t 0
  0 {$}
  262,title HLSIMAGE
  268 MOSAICWCS_
  268,t 0
  281,title {}
  274,line 29
  270 MOSAICIMAGEWCS_
  269 MOSAICIMAGE_
  error,t 0
  271 WCS_
  272 IMAGE_
  258,line 9
  273,t 0
  273 TABLE_
  266,title MECUBE
  274 SLICE_
  275 command
  271,line 25
  276 @PSEUDO1
  277,t 1
  277 save
  271,title WCS
  278 format
  261,t 0
  280 mosaicimage
  279 mosaic
  281 opts
  267,line 21
  282,t 1
  282 start'
  275,title {}
  265,t 0
  280,line 58
  279,line 53
  261,title RGBCUBE
}

proc save::yyparse {} {
    variable yylval
    variable table
    variable rules
    variable token
    variable yycnt
    variable lr1_table
    variable token_id_table
    variable yyerr
    variable save_state

    set yycnt 0
    set state_stack {0}
    set value_stack {{}}
    set token ""
    set accepted 0
    set yyerr 0
    set save_state 0

    while {$accepted == 0} {
        set state [lindex $state_stack end]
        if {$token == ""} {
            set yylval ""
            set token [yylex]
            set buflval $yylval
	    if {$token>0} {
	        incr yycnt
            }
        }
        if {![info exists table($state:$token)] || $yyerr} {
	    if {!$yyerr} {
	        set save_state $state
	    }
            # pop off states until error token accepted
            while {[llength $state_stack] > 0 && \
                       ![info exists table($state:error)]} {
                set state_stack [lrange $state_stack 0 end-1]
                set value_stack [lrange $value_stack 0 \
                                       [expr {[llength $state_stack] - 1}]]
                set state [lindex $state_stack end]
            }
            if {[llength $state_stack] == 0} {
 
	        set rr { }
                if {[info exists lr1_table($save_state,trans)] && [llength $lr1_table($save_state,trans)] >= 1} {
                    foreach trans $lr1_table($save_state,trans) {
                        foreach {tok_id nextstate} $trans {
			    set ss $token_id_table($tok_id,title)
			    if {$ss != {}} {
			        append rr "$ss, "
                            }
                        }
                    }
                }
		set rr [string trimleft $rr { }]
		set rr [string trimright $rr {, }]
                yyerror "parse error, expecting: $rr"


                return 1
            }
            lappend state_stack [set state $table($state:error,target)]
            lappend value_stack {}
            # consume tokens until it finds an acceptable one
            while {![info exists table($state:$token)]} {
                if {$token == 0} {
                    yyerror "end of file while recovering from error"
                    return 1
                }
                set yylval {}
                set token [yylex]
                set buflval $yylval
            }
            continue
        }
        switch -- $table($state:$token) {
            shift {
                lappend state_stack $table($state:$token,target)
                lappend value_stack $buflval
                set token ""
            }
            reduce {
                set rule $table($state:$token,target)
                set ll $rules($rule,l)
                if {[info exists rules($rule,e)]} {
                    set dc $rules($rule,e)
                } else {
                    set dc $rules($rule,dc)
                }
                set stackpointer [expr {[llength $state_stack]-$dc}]
                setupvalues $value_stack $stackpointer $dc
                set _ $1
                set yylval [lindex $value_stack end]
                switch -- $rule {
                    2 { global ds9; if {!$ds9(init)} {YYERROR} else {yyclearin; YYACCEPT} }
                    4 { SaveCmdLoad [ExtToFormat $1] $1 }
                    5 { SaveCmdLoad $1 $2 }
                    6 { set _ fits }
                    7 { set _ rgbimage }
                    8 { set _ rgbcube }
                    9 { set _ hlsimage }
                    10 { set _ hlscube }
                    11 { set _ hsvimage }
                    12 { set _ hsvcube }
                    13 { set _ mecube }
                    14 { set _ $1 }
                    15 { set _ $1 }
                    16 { set _ mosaic }
                    17 { set _ mosaic }
                    18 { set _ mosaic }
                    19 { set _ mosaicimage }
                    20 { set _ mosaicimage }
                    21 { set _ mosaicimage }
                    22 { ProcessCmdSet savefits type image; ProcessCmdSet savefits mosaic 1 }
                    23 { ProcessCmdSet savefits type image }
                    24 { ProcessCmdSet savefits type table }
                    25 { ProcessCmdSet savefits type slice }
                    26 { ProcessCmdSet savefits mosaic $1 }
                }
                unsetupvalues $dc
                # pop off tokens from the stack if normal rule
                if {![info exists rules($rule,e)]} {
                    incr stackpointer -1
                    set state_stack [lrange $state_stack 0 $stackpointer]
                    set value_stack [lrange $value_stack 0 $stackpointer]
                }
                # now do the goto transition
                lappend state_stack $table([lindex $state_stack end]:$ll,target)
                lappend value_stack $_
            }
            accept {
                set accepted 1
            }
            goto -
            default {
                puts stderr "Internal parser error: illegal command $table($state:$token)"
                return 2
            }
        }
    }
    return 0
}

######
# end autogenerated taccle functions
######

proc save::yyerror {msg} {
     variable yycnt
     variable yy_current_buffer
     variable index_

     ParserError $msg $yycnt $yy_current_buffer $index_
}
