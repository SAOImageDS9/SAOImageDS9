package provide DS9 1.0

######
# Begin autogenerated taccle (version 1.3) routines.
# Although taccle itself is protected by the GNU Public License (GPL)
# all user-supplied functions are protected by their respective
# author's license.  See http://mini.net/tcl/taccle for other details.
######

namespace eval rgbsend {
    variable yylval {}
    variable table
    variable rules
    variable token {}
    variable yycnt 0
    variable yyerr 0
    variable save_state 0

    namespace export yylex
}

proc rgbsend::YYABORT {} {
    return -code return 1
}

proc rgbsend::YYACCEPT {} {
    return -code return 0
}

proc rgbsend::YYERROR {} {
    variable yyerr
    set yyerr 1
}

proc rgbsend::yyclearin {} {
    variable token
    variable yycnt
    set token {}
    incr yycnt -1
}

proc rgbsend::yyerror {s} {
    puts stderr $s
}

proc rgbsend::setupvalues {stack pointer numsyms} {
    upvar 1 1 y
    set y {}
    for {set i 1} {$i <= $numsyms} {incr i} {
        upvar 1 $i y
        set y [lindex $stack $pointer]
        incr pointer
    }
}

proc rgbsend::unsetupvalues {numsyms} {
    for {set i 1} {$i <= $numsyms} {incr i} {
        upvar 1 $i y
        unset y
    }
}

array set rgbsend::table {
  2:257 shift
  5:0,target 0
  15:0,target 5
  9:0 reduce
  0:261 shift
  2:258 shift
  11:0 reduce
  2:259 shift
  2:262 shift
  4:260 shift
  0:265 shift
  2:263 shift
  15:0 reduce
  0:265,target 2
  2:263,target 10
  4:264 shift
  6:0,target 9
  2:273,target 15
  2:267 shift
  20:0 reduce
  19:0 reduce
  16:0,target 2
  0:271 shift
  2:268 shift
  4:266 shift
  0:272 shift
  2:269 shift
  2:270 shift
  0:274 goto
  2:273 shift
  6:0 reduce
  2:262,target 9
  4:260,target 17
  0:274,target 5
  2:275 goto
  7:0,target 8
  17:0,target 17
  12:0 reduce
  4:276 goto
  10:0,target 6
  16:0 reduce
  8:0,target 13
  3:0 reduce
  18:0,target 16
  1:0,target 1
  11:0,target 10
  2:259,target 8
  0:272,target 4
  2:269,target 13
  2:270,target 14
  7:0 reduce
  13:0 reduce
  9:0,target 12
  0:261,target 1
  2:258,target 7
  20:0,target 4
  19:0,target 15
  0:271,target 3
  2:268,target 12
  4:266,target 19
  12:0,target 11
  4:276,target 20
  17:0 reduce
  2:257,target 6
  2:267,target 11
  3:0,target 3
  13:0,target 7
  8:0 reduce
  10:0 reduce
  4:264,target 18
  14:0 reduce
  14:0,target 14
  18:0 reduce
  1:0 reduce
  2:275,target 16
  5:0 accept
}

array set rgbsend::rules {
  9,l 275
  11,l 275
  15,l 276
  2,l 274
  6,l 275
  12,l 275
  16,l 276
  3,l 274
  7,l 275
  13,l 275
  0,l 277
  17,l 276
  4,l 274
  8,l 275
  10,l 275
  14,l 275
  1,l 274
  5,l 275
}

array set rgbsend::rules {
  5,dc 1
  0,dc 1
  17,dc 1
  12,dc 1
  8,dc 1
  3,dc 1
  15,dc 1
  10,dc 1
  6,dc 1
  1,dc 1
  13,dc 1
  9,dc 1
  4,dc 2
  16,dc 1
  11,dc 1
  7,dc 1
  2,dc 2
  14,dc 1
}

array set rgbsend::rules {
  13,line 43
  7,line 37
  10,line 40
  4,line 32
  1,line 29
  15,line 47
  9,line 39
  12,line 42
  6,line 36
  3,line 31
  17,line 49
  14,line 44
  8,line 38
  11,line 41
  5,line 35
  2,line 30
  16,line 48
}

array set rgbsend::lr1_table {
  13,trans {}
  17 {{17 0 1}}
  0 {{0 0 0} {1 0 0} {2 0 0} {3 0 0} {4 0 0}}
  14,trans {}
  18 {{16 0 1}}
  1 {{1 0 1}}
  15,trans {}
  20 {{4 0 2}}
  19 {{15 0 1}}
  2 {{2 0 1} {5 0 0} {6 0 0} {7 0 0} {8 0 0} {9 0 0} {10 0 0} {11 0 0} {12 0 0} {13 0 0} {14 0 0}}
  16,trans {}
  3 {{3 0 1}}
  17,trans {}
  4 {{4 0 1} {15 0 0} {16 0 0} {17 0 0}}
  0,trans {{261 1} {265 2} {271 3} {272 4} {274 5}}
  18,trans {}
  5 {{0 0 1}}
  1,trans {}
  20,trans {}
  19,trans {}
  2,trans {{257 6} {258 7} {259 8} {262 9} {263 10} {267 11} {268 12} {269 13} {270 14} {273 15} {275 16}}
  6 {{9 0 1}}
  3,trans {}
  7 {{8 0 1}}
  4,trans {{260 17} {264 18} {266 19} {276 20}}
  8 {{13 0 1}}
  5,trans {}
  10 {{6 0 1}}
  9 {{12 0 1}}
  6,trans {}
  11 {{10 0 1}}
  7,trans {}
  12 {{11 0 1}}
  8,trans {}
  13 {{7 0 1}}
  10,trans {}
  9,trans {}
  14 {{14 0 1}}
  11,trans {}
  15 {{5 0 1}}
  12,trans {}
  16 {{2 0 2}}
}

array set rgbsend::token_id_table {
  264,line 15
  270,t 0
  269,t 0
  276,line 46
  265,title LOCK
  274,t 1
  261,line 12
  257,t 0
  270,title SMOOTH
  269,title SLICE
  273,line 24
  257,line 8
  262,t 0
  274,title {}
  270,line 21
  269,line 20
  259,title BLOCK
  260,title BLUE
  266,t 0
  error error
  271,t 0
  264,title GREEN
  266,line 17
  275,t 1
  error,line 27
  268,title SCALELIMITS
  258,t 0
  263,line 14
  error,title {}
  275,line 34
  273,title WCS
  263,t 0
  259,line 10
  260,line 11
  258,title BIN
  277,title {}
  272,line 23
  267,t 0
  263,title CROP
  272,t 0
  268,line 19
  267,title SCALE
  257 AXES_
  276,t 1
  258 BIN_
  259,t 0
  259 BLOCK_
  260 BLUE_
  260,t 0
  272,title VIEW
  261 CHANNEL_
  265,line 16
  262 COLORBAR_
  263 CROP_
  277,line 50
  257,title AXES
  264 GREEN_
  264,t 0
  276,title {}
  265 LOCK_
  262,line 13
  266 RED_
  267 SCALE_
  0,t 0
  0 {$}
  262,title COLORBAR
  268 SCALELIMITS_
  268,t 0
  274,line 28
  270 SMOOTH_
  269 SLICE_
  error,t 0
  271 SYSTEM_
  272 VIEW_
  258,line 9
  273,t 0
  273 WCS_
  266,title RED
  274 rgbsend
  275 lock
  271,line 22
  276 view
  277,t 1
  277 start'
  271,title SYSTEM
  261,t 0
  267,line 18
  275,title {}
  265,t 0
  261,title CHANNEL
}

proc rgbsend::yyparse {} {
    variable yylval
    variable table
    variable rules
    variable token
    variable yycnt
    variable lr1_table
    variable token_id_table
    variable yyerr
    variable save_state

    set yycnt 0
    set state_stack {0}
    set value_stack {{}}
    set token ""
    set accepted 0
    set yyerr 0
    set save_state 0

    while {$accepted == 0} {
        set state [lindex $state_stack end]
        if {$token == ""} {
            set yylval ""
            set token [yylex]
            set buflval $yylval
	    if {$token>0} {
	        incr yycnt
            }
        }
        if {![info exists table($state:$token)] || $yyerr} {
	    if {!$yyerr} {
	        set save_state $state
	    }
            # pop off states until error token accepted
            while {[llength $state_stack] > 0 && \
                       ![info exists table($state:error)]} {
                set state_stack [lrange $state_stack 0 end-1]
                set value_stack [lrange $value_stack 0 \
                                       [expr {[llength $state_stack] - 1}]]
                set state [lindex $state_stack end]
            }
            if {[llength $state_stack] == 0} {
 
	        set rr { }
                if {[info exists lr1_table($save_state,trans)] && [llength $lr1_table($save_state,trans)] >= 1} {
                    foreach trans $lr1_table($save_state,trans) {
                        foreach {tok_id nextstate} $trans {
			    set ss $token_id_table($tok_id,title)
			    if {$ss != {}} {
			        append rr "$ss, "
                            }
                        }
                    }
                }
		set rr [string trimleft $rr { }]
		set rr [string trimright $rr {, }]
                yyerror "parse error, expecting: $rr"


                return 1
            }
            lappend state_stack [set state $table($state:error,target)]
            lappend value_stack {}
            # consume tokens until it finds an acceptable one
            while {![info exists table($state:$token)]} {
                if {$token == 0} {
                    yyerror "end of file while recovering from error"
                    return 1
                }
                set yylval {}
                set token [yylex]
                set buflval $yylval
            }
            continue
        }
        switch -- $table($state:$token) {
            shift {
                lappend state_stack $table($state:$token,target)
                lappend value_stack $buflval
                set token ""
            }
            reduce {
                set rule $table($state:$token,target)
                set ll $rules($rule,l)
                if {[info exists rules($rule,e)]} {
                    set dc $rules($rule,e)
                } else {
                    set dc $rules($rule,dc)
                }
                set stackpointer [expr {[llength $state_stack]-$dc}]
                setupvalues $value_stack $stackpointer $dc
                set _ $1
                set yylval [lindex $value_stack end]
                switch -- $rule {
                    1 { ProcessSendCmdGet current rgb }
                    2 { ProcessSendCmdYesNo rgb lock,$2 }
                    3 { ProcessSendCmdGet rgb system }
                    4 { ProcessSendCmdYesNo rgb $2 }
                    5 { set _ wcs }
                    6 { set _ crop }
                    7 { set _ slice }
                    8 { set _ bin }
                    9 { set _ axes }
                    10 { set _ scale }
                    11 { set _ scalelimits }
                    12 { set _ colorbar }
                    13 { set _ block }
                    14 { set _ smooth }
                    15 { set _ red }
                    16 { set _ green }
                    17 { set _ blue }
                }
                unsetupvalues $dc
                # pop off tokens from the stack if normal rule
                if {![info exists rules($rule,e)]} {
                    incr stackpointer -1
                    set state_stack [lrange $state_stack 0 $stackpointer]
                    set value_stack [lrange $value_stack 0 $stackpointer]
                }
                # now do the goto transition
                lappend state_stack $table([lindex $state_stack end]:$ll,target)
                lappend value_stack $_
            }
            accept {
                set accepted 1
            }
            goto -
            default {
                puts stderr "Internal parser error: illegal command $table($state:$token)"
                return 2
            }
        }
    }
    return 0
}

######
# end autogenerated taccle functions
######

proc rgbsend::yyerror {msg} {
     variable yycnt
     variable yy_current_buffer
     variable index_

     ParserError $msg $yycnt $yy_current_buffer $index_
}
