package provide DS9 1.0

######
# Begin autogenerated taccle (version 1.3) routines.
# Although taccle itself is protected by the GNU Public License (GPL)
# all user-supplied functions are protected by their respective
# author's license.  See http://mini.net/tcl/taccle for other details.
######

namespace eval blink {
    variable yylval {}
    variable table
    variable rules
    variable token {}
    variable yycnt 0
    variable yyerr 0
    variable save_state 0

    namespace export yylex
}

proc blink::YYABORT {} {
    return -code return 1
}

proc blink::YYACCEPT {} {
    return -code return 0
}

proc blink::YYERROR {} {
    variable yyerr
    set yyerr 1
}

proc blink::yyclearin {} {
    variable token
    variable yycnt
    set token {}
    incr yycnt -1
}

proc blink::yyerror {s} {
    puts stderr $s
}

proc blink::setupvalues {stack pointer numsyms} {
    upvar 1 1 y
    set y {}
    for {set i 1} {$i <= $numsyms} {incr i} {
        upvar 1 $i y
        set y [lindex $stack $pointer]
        incr pointer
    }
}

proc blink::unsetupvalues {numsyms} {
    for {set i 1} {$i <= $numsyms} {incr i} {
        upvar 1 $i y
        unset y
    }
}

array set blink::table {
  7:264,target 13
  0:257 shift
  11:265 reduce
  0:258 shift
  0:259 shift
  0:260 shift
  5:0,target 3
  13:265 reduce
  9:0 reduce
  0:266,target 7
  0:261 shift
  11:0 reduce
  0:262 shift
  15:265 shift
  11:271 goto
  7:263,target 12
  0:265 reduce
  5:265,target 3
  0:266 shift
  0:267 goto
  2:265 reduce
  0:268 goto
  0:265,target 12
  6:0,target 6
  0:270 goto
  4:265 reduce
  16:0,target 11
  2:0 reduce
  12:265,target 7
  6:265 reduce
  0:272 goto
  8:265 reduce
  6:0 reduce
  11:271,target 15
  8:265,target 13
  12:0 reduce
  0:0,target 12
  3:265,target 2
  10:0,target 0
  15:265,target 16
  16:0 reduce
  8:0,target 13
  7:269,target 14
  3:0 reduce
  1:0,target 1
  11:0,target 9
  0:262,target 6
  6:265,target 6
  0:272,target 11
  12:265 reduce
  1:265,target 1
  14:265 reduce
  13:265,target 8
  13:0 reduce
  9:0,target 14
  0:261,target 5
  2:0,target 4
  12:0,target 7
  1:265 reduce
  0:0 reduce
  3:265 reduce
  9:265,target 14
  7:263 shift
  5:265 reduce
  7:264 shift
  0:259,target 3
  0:260,target 4
  0:270,target 10
  4:0 reduce
  4:265,target 5
  9:265 reduce
  3:0,target 2
  13:0,target 8
  8:0 reduce
  7:269 goto
  10:0 accept
  11:265,target 10
  0:258,target 2
  0:268,target 9
  14:0 reduce
  4:0,target 5
  14:0,target 15
  0:257,target 1
  1:0 reduce
  0:267,target 8
  2:265,target 4
  14:265,target 15
  5:0 reduce
}

array set blink::rules {
  9,l 270
  11,l 270
  15,l 272
  2,l 267
  6,l 268
  12,l 272
  3,l 267
  7,l 269
  13,l 272
  0,l 273
  4,l 268
  8,l 269
  10,l 271
  14,l 272
  1,l 267
  5,l 268
}

array set blink::rules {
  5,dc 1
  0,dc 1
  12,dc 0
  8,dc 1
  3,dc 1
  15,dc 2
  10,dc 0
  6,dc 1
  1,dc 1
  13,dc 1
  9,dc 1
  4,dc 1
  11,dc 3
  7,dc 1
  2,dc 1
  14,dc 1
}

array set blink::rules {
  13,line 56
  7,line 47
  10,line 51
  4,line 43
  1,line 38
  15,line 58
  9,line 51
  12,line 55
  6,line 45
  3,line 40
  14,line 57
  10,e 1
  8,line 48
  11,line 52
  5,line 44
  2,line 39
}

array set blink::lr1_table {
  13,trans {}
  0 {{0 0 0} {9 0 0} {11 0 0} {12 {0 265} 0} {13 {0 265} 0} {14 {0 265} 0} {15 {0 265} 0} {1 {0 265} 0} {2 {0 265} 0} {3 {0 265} 0} {4 {0 265} 0} {5 {0 265} 0} {6 {0 265} 0}}
  14,trans {}
  1 {{1 {0 265} 1}}
  15,trans {{265 16}}
  2 {{4 {0 265} 1}}
  16,trans {}
  3 {{2 {0 265} 1}}
  0,trans {{257 1} {258 2} {259 3} {260 4} {261 5} {262 6} {266 7} {267 8} {268 9} {270 10} {272 11}}
  4 {{5 {0 265} 1}}
  1,trans {}
  5 {{3 {0 265} 1}}
  2,trans {}
  6 {{6 {0 265} 1}}
  3,trans {}
  7 {{15 {0 265} 1} {7 {0 265} 0} {8 {0 265} 0}}
  4,trans {}
  8 {{13 {0 265} 1}}
  5,trans {}
  9 {{14 {0 265} 1}}
  10 {{0 0 1}}
  6,trans {}
  11 {{9 0 1} {11 0 1} {10 265 0}}
  7,trans {{263 12} {264 13} {269 14}}
  12 {{7 {0 265} 1}}
  8,trans {}
  13 {{8 {0 265} 1}}
  10,trans {}
  9,trans {}
  14 {{15 {0 265} 2}}
  11,trans {{271 15}}
  15 {{11 0 2}}
  16 {{11 0 3}}
  12,trans {}
}

array set blink::token_id_table {
  264,line 15
  270,t 1
  269,t 1
  265,title string
  261,line 11
  257,t 0
  270,title {}
  269,title {}
  273,line 59
  257,line 7
  262,t 0
  270,line 50
  269,line 46
  259,title ON
  260,title OFF
  266,t 0
  271,t 1
  264,title float
  266,line 21
  error error
  268,title {}
  error,line 36
  258,t 0
  263,line 14
  error,title {}
  273,title {}
  263,t 0
  259,line 9
  260,line 10
  258,title NO
  272,line 54
  267,t 1
  263,title integer
  272,t 1
  268,line 42
  267,title {}
  257 YES_
  258 NO_
  259,t 0
  259 ON_
  260 OFF_
  260,t 0
  272,title {}
  261 TRUE_
  265,line 17
  262 FALSE_
  263 INT_
  257,title YES
  264 REAL_
  264,t 0
  265 STRING_
  262,line 12
  266 INTERVAL_
  267 yes
  268,t 1
  268 no
  262,title FALSE
  0 {$}
  0,t 0
  270 command
  269 numeric
  271 @PSEUDO1
  error,t 0
  272 blink
  258,line 8
  273,t 1
  273 start'
  266,title INTERVAL
  271,line 51
  271,title {}
  261,t 0
  267,line 37
  265,t 0
  261,title TRUE
}

proc blink::yyparse {} {
    variable yylval
    variable table
    variable rules
    variable token
    variable yycnt
    variable lr1_table
    variable token_id_table
    variable yyerr
    variable save_state

    set yycnt 0
    set state_stack {0}
    set value_stack {{}}
    set token ""
    set accepted 0
    set yyerr 0
    set save_state 0

    while {$accepted == 0} {
        set state [lindex $state_stack end]
        if {$token == ""} {
            set yylval ""
            set token [yylex]
            set buflval $yylval
	    if {$token>0} {
	        incr yycnt
            }
        }
        if {![info exists table($state:$token)] || $yyerr} {
	    if {!$yyerr} {
	        set save_state $state
	    }
            # pop off states until error token accepted
            while {[llength $state_stack] > 0 && \
                       ![info exists table($state:error)]} {
                set state_stack [lrange $state_stack 0 end-1]
                set value_stack [lrange $value_stack 0 \
                                       [expr {[llength $state_stack] - 1}]]
                set state [lindex $state_stack end]
            }
            if {[llength $state_stack] == 0} {
 
	        set rr { }
                if {[info exists lr1_table($save_state,trans)] && [llength $lr1_table($save_state,trans)] >= 1} {
                    foreach trans $lr1_table($save_state,trans) {
                        foreach {tok_id nextstate} $trans {
			    set ss $token_id_table($tok_id,title)
			    if {$ss != {}} {
			        append rr "$ss, "
                            }
                        }
                    }
                }
		set rr [string trimleft $rr { }]
		set rr [string trimright $rr {, }]
                yyerror "parse error, expecting: $rr"


                return 1
            }
            lappend state_stack [set state $table($state:error,target)]
            lappend value_stack {}
            # consume tokens until it finds an acceptable one
            while {![info exists table($state:$token)]} {
                if {$token == 0} {
                    yyerror "end of file while recovering from error"
                    return 1
                }
                set yylval {}
                set token [yylex]
                set buflval $yylval
            }
            continue
        }
        switch -- $table($state:$token) {
            shift {
                lappend state_stack $table($state:$token,target)
                lappend value_stack $buflval
                set token ""
            }
            reduce {
                set rule $table($state:$token,target)
                set ll $rules($rule,l)
                if {[info exists rules($rule,e)]} {
                    set dc $rules($rule,e)
                } else {
                    set dc $rules($rule,dc)
                }
                set stackpointer [expr {[llength $state_stack]-$dc}]
                setupvalues $value_stack $stackpointer $dc
                set _ $1
                set yylval [lindex $value_stack end]
                switch -- $rule {
                    1 { set _ 1 }
                    2 { set _ 1 }
                    3 { set _ 1 }
                    4 { set _ 0 }
                    5 { set _ 0 }
                    6 { set _ 0 }
                    7 { set _ $1 }
                    8 { set _ $1 }
                    10 { global ds9; if {!$ds9(init)} {YYERROR} else {yyclearin; YYACCEPT} }
                    12 { ProcessCmdSet current display blink DisplayMode }
                    13 { ProcessCmdSet current display blink DisplayMode }
                    14 { ProcessCmdSet current display single DisplayMode }
                    15 { ProcessCmdSet blink interval [expr int($2*1000)] DisplayMode }
                }
                unsetupvalues $dc
                # pop off tokens from the stack if normal rule
                if {![info exists rules($rule,e)]} {
                    incr stackpointer -1
                    set state_stack [lrange $state_stack 0 $stackpointer]
                    set value_stack [lrange $value_stack 0 $stackpointer]
                }
                # now do the goto transition
                lappend state_stack $table([lindex $state_stack end]:$ll,target)
                lappend value_stack $_
            }
            accept {
                set accepted 1
            }
            goto -
            default {
                puts stderr "Internal parser error: illegal command $table($state:$token)"
                return 2
            }
        }
    }
    return 0
}

######
# end autogenerated taccle functions
######

proc blink::yyerror {msg} {
     variable yycnt
     variable yy_current_buffer
     variable index_

     ParserError $msg $yycnt $yy_current_buffer $index_
}
